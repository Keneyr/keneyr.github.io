{"pages":[{"title":"","text":"","link":"/CV/index.html"},{"title":"About Me","text":"Currently I’m a Game Client Programmer. I have worked in Garena, participating in developing FreeFire(2021.11-2022.9) and Tencent, participating in developing Arena of Valor(2020.9-2021.1,Intern). I have received my Master’s degree in Computer Science and Technology from Beijing Forestry University. My research interest includes Computer Graphics, Computer Animation, Machine Learning. Now I’m persuing a phd position on Computer Animation or Computer Vision, please contact me if you’re interested in me. You can find my CV here: Anna’s Curriculum Vitae. Email / Github / CSDN","link":"/about/index.html"},{"title":"","text":"Computer Animation Groups: Peking University, China ETH Zurich, Swiss The University of British Columbia, Canada Useful Animation Videos or Materials: Books: 3D Math Primer for Graphics and Game Development 2nd Edition &gt;&gt;Reading Notes Computer Animation Algorithms and Techniques &gt;&gt;Reading Notes Useful MachineLearning Materials: Books: A First Course in Probability &gt;&gt;Reading Notes Linear Algebra and Its Application &gt;&gt;Reading Notes Pattern Recognition and Machine Learning &gt;&gt;Reading Notes Useful CS Materials: Books: C++ Primer &gt;&gt;Reading Notes Introduction to Algorithms &gt;&gt;Reading Notes","link":"/extra/index.html"},{"title":"Life Photo","text":"Cooking garlic fried chicken korean fried chicken spicy boston lobster braised crucian carp spicy crayfish beer braised duck sweet and sour pork(guo bao rou) fried rice with egg golden enoki mushroom beef soup fried fensi durian melaleuca bean sprouts(get-lean diet)","link":"/life/index.html"},{"title":"","text":"Video-Driven 2D Character Animation Qinran YIN & Weiqun CAO Chinese Journal of Electronics, vol. 30, no. 6, pp. 1038-1048, 2021 [Project page][Paper] [Code]","link":"/publication/index.html"},{"title":"","text":"Pattern Recognition and Machine Learning C1:","link":"/reading/index.html"},{"title":"Work","text":"","link":"/work/index.html"},{"title":"","text":"Study of Video-driven 2D Character Animation Generation Method Abstract Video-driven animation has always been a hot and challenging topic in the field of computer animation. We propose a method of mapping a sequence of human skeletal keypoints in a video onto a two-dimensional character to generate 2D character animation. For a given two-dimensional character picture, we extract the motion of real human in video data, driving the character deformation. We analyze common two-dimensional human body movements, classify the basic posture of the human body, realize the recognition of skeleton posture based on back propagation network, capture human body motion by automatically tracking the position of the human skeleton keypoints coordinates in the video and redirect the motion data to a 2D character. Compared with the traditional method, our work is less affected by video data illumination and background complexity. We calibrate human body motion in videos to a 2D character according to the skeleton topology to avoid motion distortion caused by the difference in skeleton size and ratio. The experimental results show that the proposed algorithm can generate the motion of two-dimensional characters based on the motion of human characters in video data. The animation is natural and smooth, and the algorithm has strong robustness. Conclution and Future work This paper proposes a method of mapping human motion data in a video onto a two-dimensional character to generate character animation. We statistically analyze common two-dimensional human body movements, classify the basic posture of the human body; design and implement the method of human body posture recognition based on the skeleton information on images and videos; propose a geometric calibration method based on the tree structure to correct motion reorientation of the bones, obtaining a good skeleton-driven deformation effect, and generating high quality animation in the same posture. This method can be used to auto-produced animation, which need fewer user interaction. Although our method maps the sequence of human skeletal postures in the video onto a two-dimensional character, resulting in a high quality animation, there is some room for improvement: 1) Scope of application. Our method is only for 2D human characters, cannot be extended to other types of images such as animals and plants; 2) Physical simulation. We didn’t take some phenomena such as hair, clothes into consideration, thus these deformation was not natural enough, as shown in Fig.14(e), the man’s hair deforms in a stiff way. In the future, we will try to improve the issues discussed above, an approach for animals and plants animation will be adapted by this method, physical simulation will be used to get higher quality results. On the other hand, we will also integrate all methods into one interactive animation system.","link":"/projects/index.html"}],"posts":[{"title":"3DMath-Transformation","text":"Keywords: Coordinate Space, Transformation, Matrix, Quaternions, Polar Coordinate System Attetion: left-hand rule, row vectors, right multiply. Deduce the Projection and Rotation MatrixPerspective Projection Matrix from the picture above, the projection plane is $z = d$, by similar triangles, we can see that $$\\frac{p_y’}{d} = \\frac{p_y}{z}\\Rightarrow p_y’ = \\frac{dp_y}{z}, also \\space p_x’ = \\frac{dp_x}{z}$$ so $$p = \\begin{bmatrix} x &amp; y &amp; z \\end{bmatrix}\\longmapsto\\begin{aligned}p’ &amp;= \\begin{bmatrix} \\frac{dx}{z} &amp; \\frac{dy}{z} &amp; \\frac{dz}{z} \\end{bmatrix}\\\\&amp;= \\frac{\\begin{bmatrix} x &amp; y &amp; z \\end{bmatrix}}{z/d}\\end{aligned}$$ So we need a $4 \\times 4$ matrix that multiplies a homogeneous vector $[x, y, z, 1]$ to produce $[x, y, z, z/d]$. The matrix that does this is $$\\begin{bmatrix}x &amp; y &amp; z &amp; 1\\end{bmatrix}\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 1/d\\\\0 &amp; 0 &amp; 0 &amp; 0\\end{bmatrix}=\\begin{bmatrix}x &amp; y &amp; z &amp; z/d\\end{bmatrix}$$ Multiplication by this matrix doesn’t actually perform the perspective transform, it just computes the proper denominator into $w(w = z/d)$. Remember that the perspective division actually occurs when we convert from $4D$ to $3D$ by dividing by $w$. Orthogonal Projection MatrixRotation Matrix3D Rotation about Cardinal Axes matrix to rotate about the $x-axis$:$$R_x(\\theta) =\\begin{bmatrix}1 &amp; 0 &amp; 0\\\\0 &amp; \\cos\\theta &amp; \\sin \\theta\\\\0 &amp; -\\sin \\theta &amp; \\cos \\theta\\end{bmatrix}$$ matrix to rotate about the $y-axis$:$$R_y(\\theta) =\\begin{bmatrix}\\cos\\theta &amp; 0 &amp; -\\sin\\theta \\\\0 &amp; 1 &amp; 0\\\\\\sin\\theta &amp; 0 &amp; \\cos\\theta\\end{bmatrix}$$ matrix to rotate about the $z-axis$:$$R_z(\\theta) =\\begin{bmatrix}\\cos\\theta &amp; \\sin\\theta &amp; 0\\\\-\\sin\\theta &amp; \\cos\\theta &amp; 0\\\\0 &amp; 1 &amp; 0\\end{bmatrix}$$ 3D Rotation about Arbitrary AxisLet’s derive a matrix to rotate about $\\widehat{\\vec{n}}$ by the angle $\\theta$. that means: $$\\vec{v}’ = \\vec{v}R(\\widehat{\\vec{n}},\\theta)$$ The basic idea is to solve the problem in the plane perpendicular to $\\widehat{\\vec{n}}$. we separate $\\vec{v}$ into two vectors, $\\vec{v_{\\parallel}}$ and $\\vec{v_{\\perp}}$, which are parallel and perpendicular to $\\vec{v}$, respectively, such that $\\vec{v} = \\vec{v_{\\parallel}} + \\vec{v_{\\perp}}$. By rotating each of these components individually, we can rotate the vector as a whole. In other words, $\\vec{v’} = \\vec{v_{\\parallel}’} + \\vec{v_{\\perp}’}$. Since $\\vec{v_{\\parallel}}$ is parallel to $\\widehat{\\vec{n}}$, it will not be affected by the rotation about $\\widehat{\\vec{n}}$. In other words, $\\vec{v_{\\parallel}’} = \\vec{v_{\\parallel}}$. So all we need to do is compute $\\vec{v_{\\perp}’}$, and then we have $\\vec{v’} = \\vec{v_{\\parallel}’} + \\vec{v_{\\perp}’}$. To compute $\\vec{v_{\\perp}’}$ , we construct the vectors $\\vec{v_{\\parallel}}$ and $\\vec{v_{\\perp}}$ and an intermediate vector $\\vec{w}$, The vector $\\vec{w}$ is mutually perpendicular to $\\vec{v_{\\parallel}}$ and $\\vec{v_{\\perp}}$ and has the same length as $\\vec{v_{\\perp}}$: $$\\begin{aligned}\\vec{v_{\\parallel}} &amp;= (\\vec{v} \\cdot \\widehat{\\vec{n}})\\widehat{\\vec{n}}\\\\\\vec{v_{\\perp}} &amp;= \\vec{v} - \\vec{v_{\\parallel}} \\\\&amp;= \\vec{v} - (\\vec{v} \\cdot \\widehat{\\vec{n}})\\widehat{\\vec{n}} \\\\\\vec{w} &amp;= \\widehat{\\vec{n}} \\times \\vec{v_{\\perp}} \\\\&amp;= \\widehat{\\vec{n}} \\times (\\vec{v} - \\vec{v_{\\parallel}})\\\\&amp;= \\widehat{\\vec{n}} \\times \\vec{v} - \\widehat{\\vec{n}} \\times \\vec{v_{\\parallel}}\\\\&amp;= \\widehat{\\vec{n}} \\times \\vec{v}\\end{aligned}$$ How do these vectors help us compute $\\vec{v_{\\perp}’}$? Notice that $\\vec{w}$ and $\\vec{v_{\\perp}}$ form a 2D coordinate space, with $\\vec{v_{\\perp}}$ as the $“x-axis”$ and $\\vec{w}$ as the $“y-axis”$. (Note that the two vectors don’t necessarily have unit length.) $\\vec{v_{\\perp}’}$ is the result of rotating $\\vec{v’}$ in this plane by the angle $θ$. Remember the endpoints of a unit ray rotated by an angle $\\theta$ are $\\cos\\theta$ and $\\sin\\theta$? $$\\begin{aligned}\\vec{p’} &amp;= \\cos \\theta \\vec{e_1} + \\sin \\theta \\vec{e_1} \\\\&amp;= \\cos\\theta \\begin{bmatrix} 1 &amp; 0\\end{bmatrix} + \\sin\\theta \\begin{bmatrix} 0 &amp; 1\\end{bmatrix}\\\\&amp;= \\begin{bmatrix} \\cos\\theta &amp; 0\\end{bmatrix} + \\begin{bmatrix} 0 &amp; \\sin\\theta\\end{bmatrix} \\\\&amp;= \\begin{bmatrix} \\cos\\theta &amp; \\sin\\theta \\end{bmatrix}\\end{aligned}$$The only difference here is that our ray is not a unit ray, and we are using $\\vec{v_{\\perp}}$ and $\\vec{w}$ as our basis vectors. Thus, $\\vec{v_{\\perp}’}$ can be computed as $$\\begin{aligned}\\vec{v_{\\perp}’} &amp;= \\cos\\theta \\vec{v_{\\perp}} + \\sin\\theta \\vec{w}\\\\&amp;= \\cos\\theta (\\vec{v} - (\\vec{v} \\cdot \\widehat{\\vec{n}})\\widehat{\\vec{n}}) + \\sin\\theta (\\widehat{\\vec{n}} \\times \\vec{v})\\end{aligned}$$ Thus, $$\\begin{aligned}\\vec{v’} &amp;= \\vec{v_{\\parallel}’} + \\vec{v_{\\perp}’} \\\\&amp;= \\cos\\theta (\\vec{v} - (\\vec{v} \\cdot \\widehat{\\vec{n}})\\widehat{\\vec{n}}) + \\sin\\theta (\\widehat{\\vec{n}} \\times \\vec{v}) + (\\vec{v} \\cdot \\widehat{\\vec{n}})\\widehat{\\vec{n}}\\end{aligned}\\tag{5.1}$$ the remaining arithmetic is essentially a notational change that expresses Equation (5.1) as a matrix multiplication. Now that we have expressed $\\vec{v’}$ in terms of $\\vec{v}, \\widehat{\\vec{n}}$ and $θ$. we can compute what the basis vectors are after transformation and construct our matrix.$$\\vec{e_1} = \\begin{bmatrix} 1 &amp; 0 &amp; 0\\end{bmatrix}\\longmapsto\\vec{e_1’} =\\begin{bmatrix}n_x^2(1-\\cos\\theta) + \\cos\\theta\\\\n_x n_y(1-\\cos\\theta) + n_z \\sin\\theta\\\\n_x n_z(1-\\cos\\theta) - n_y\\sin\\theta\\end{bmatrix}^T$$$$\\vec{e_2} = \\begin{bmatrix} 0 &amp; 1 &amp; 0\\end{bmatrix}\\longmapsto\\vec{e_2’} =\\begin{bmatrix}n_x n_y(1-\\cos\\theta) - n_z \\sin\\theta\\\\n_y^2(1-\\cos\\theta) + \\cos\\theta\\\\n_y n_z(1-\\cos\\theta) + n_x\\sin\\theta\\end{bmatrix}^T$$$$\\vec{e_3} = \\begin{bmatrix} 0 &amp; 0 &amp; 1\\end{bmatrix}\\longmapsto\\vec{e_3’} =\\begin{bmatrix}n_x n_z(1-\\cos\\theta) + n_y\\sin\\theta\\\\n_y n_z(1-\\cos\\theta) - n_x \\sin\\theta\\\\n_z^2(1-\\cos\\theta) +\\cos\\theta\\end{bmatrix}^T$$Thus $$\\begin{aligned}R(\\widehat{\\vec{n}},\\theta) &amp;=\\begin{bmatrix}R(\\vec{e_1}) &amp; R(\\vec{e_2}) &amp; R(\\vec{e_3’})\\end{bmatrix}^T\\\\&amp;=\\begin{bmatrix}\\vec{e_1’} &amp; \\vec{e_2’} &amp; \\vec{e_3’}\\end{bmatrix}^T\\\\&amp;=\\begin{bmatrix}n_x^2(1-\\cos\\theta) + \\cos\\theta &amp; n_x n_y(1-\\cos\\theta) + n_z \\sin\\theta &amp; n_x n_z(1-\\cos\\theta) - n_y\\sin\\theta\\\\n_x n_y(1-\\cos\\theta) - n_z \\sin\\theta &amp; n_y^2(1-\\cos\\theta) + \\cos\\theta &amp; n_y n_z(1-\\cos\\theta) + n_x\\sin\\theta\\\\n_x n_z(1-\\cos\\theta) + n_y\\sin\\theta &amp; n_y n_z(1-\\cos\\theta) - n_x \\sin\\theta &amp; n_z^2(1-\\cos\\theta) +\\cos\\theta\\end{bmatrix}\\end{aligned}$$ How to understand Basis in Linear Algebra &gt;&gt; How to understand Basis and Coordinate Systems in Linear Algebra &gt;&gt; How to understand Basis and Coordinate Systems and Coordinate Mapping in Linear Algebra &gt;&gt; QuaternionAppendix$$OpenGL-perspective-matrix:\\begin{bmatrix} \\frac{1}{aspect _ ratio \\cdot tan\\frac{\\theta}{2}} &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; \\frac{1}{tan \\frac{\\theta}{2}} &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; \\frac{zFar+zNear}{zNear-zFar}&amp; \\frac{2 \\cdot zNear \\cdot zFar}{zNear-zFar} \\\\ 0 &amp; 0 &amp; -1 &amp; 0 \\\\\\end{bmatrix} $$ $$OpenGL-perspective-matrix:\\begin{bmatrix} \\frac{2|n|}{r-l} &amp; 0 &amp; \\frac{r+l}{r-l} &amp; 0 \\\\ 0 &amp; \\frac{2|n|}{t-b} &amp; \\frac{t+b}{t-b} &amp; 0 \\\\ 0 &amp; 0 &amp; \\frac{|n|+|f|}{|n|-|f|} &amp; \\frac{2|f||n|}{|n|-|f|} \\\\ 0 &amp; 0 &amp; -1 &amp; 0 \\\\\\end{bmatrix} $$ $$OpenGL-orthographic-matrix:\\begin{bmatrix} \\frac{1}{aspect _ ratio*tan \\frac{\\theta}{2}} &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; \\frac{1}{tan \\frac{\\theta}{2}} &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; \\frac{2}{zNear-zFar} &amp; \\frac{zNear+zFar}{zNear-zFar} \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\\\end{bmatrix} $$ so,for the OpenGL conventions, we can tell whether a projection matrix is perspective or orthographic based on the bottom row.$$OpenGL-Perspective\\begin{bmatrix} 0 &amp; 0 &amp; -1 &amp; 0 \\end{bmatrix}$$$$penGL-Orthographic\\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix}$$ $$Dx-orthographic-matrix:\\begin{bmatrix} \\frac{2}{w} &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; \\frac{2}{h} &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; \\frac{1}{zF-zN} &amp; 0 \\\\ 0 &amp; 0 &amp; \\frac{zn}{zN-zF} &amp; 1 \\\\\\end{bmatrix}$$ $$Dx-perspective-matrix:\\begin{bmatrix} \\frac{1}{aspect _ ratio*tan \\frac{\\theta}{2}} &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; \\frac{1}{tan \\frac{\\theta}{2}} &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; \\frac{zF}{zF-zN} &amp; 1 \\\\ 0 &amp; 0 &amp; \\frac{zN \\cdot zF}{zN-zF} &amp; 1 \\\\\\end{bmatrix}$$ OpenGL use column vectors, Projection_Matrix * View_Matrix * Model_Matrix * VectorDirectx use row vectors, Vector * Model_Matrx * View_Matrx * Projection_Matrix","link":"/Math/Geometry/3DMath-Transformation/"},{"title":"C1-Linear-Equation-in-Linear-Algebra","text":"Keywords: Aumented matrix, Linear Independence, Linear Transformation System of Linear EquationsLinear Equation:$$a_1 x_1 + a_2 x_2 + … + a_n x_n = b$$ NonLinear Equation:$$4 x_1 - 5 x_2 = x_1x_2$$ Linear System$$\\begin{cases}&amp;2 x_1 - x_2 + 1.5 x_3 = 8 \\\\&amp;x_1 - 4 x_3 = -7\\end{cases}\\tag{2}$$ Solution setThe set of all possible solutions is called the solution set of the linear system. e.g. (5, 6.5, 3) is a solution of system(2) Two linear systems are called equivalent if they have the same solution set.A system of linear equations has no solution, or exactly one solution, or infinitely many solutions Augmented Matrix$$\\begin{cases}x_1 - 2 x_2 + x_3 = 0\\\\2x_2 - 8x_3 = 8 \\\\5x_1 - 5x_3 = 10\\end{cases}\\rightarrow\\begin{bmatrix}1 &amp; -2 &amp; 1 &amp; 0 \\\\0 &amp; 2 &amp; -8 &amp; 8\\\\5 &amp; 0 &amp; -5 &amp; 10\\end{bmatrix}$$ Solving a Linear SystemThe procedure can also be called simplify the augmented matrix(化简增广矩阵的过程就是在求线性方程组的解) $$\\begin{cases}x_1 = 1, \\\\x_2 = 0, \\\\x_3 = -1\\end{cases}\\rightarrow\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 1 \\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; -1\\end{bmatrix}$$ ELEMENTARY ROW OPERATIONS (Replacement) Replace one row by the sum of itself and a multiple of another row (Interchange) Interchange two rows. (Scaling) Multiply all entries in a row by a nonzero constant Existence and Uniqueness Questionsthis system solution is unique, this system is consistent:$$\\begin{cases}x_1 - 2 x_ 2 + x_3 = 0\\\\x_2 - 4x_3 = 4\\\\x_3 = -1\\end{cases}\\rightarrow\\begin{bmatrix}1 &amp; -2 &amp; 1 &amp; 0 \\\\0 &amp; 1 &amp; -4 &amp; 4\\\\0 &amp; 0 &amp; 1 &amp; -1\\end{bmatrix}$$ Row Reduction and Echelon Formsa nonzero row or columna row or column that contains at least one nonzero entry leading entrya leading entry of a row refers to the leftmost nonzero entry (in a nonzero row) A rectangular matrix is in echelon form (or row echelon form) if it has the following three properties: All nonzero rows are above any rows of all zeros. Each leading entry of a row is in a column to the right of the leading entry of the row above it. All entries in a column below a leading entry are zeros.If a matrix in echelon form satisfies the following additional conditions, then it is in reduced echelon form (or reduced row echelon form): The leading entry in each nonzero row is 1. Each leading 1 is the only nonzero entry in its column. 行阶梯矩阵 row echelon form$$\\begin{bmatrix}2 &amp; -3 &amp; 2 &amp; 1 \\\\0 &amp; 1 &amp; -4 &amp; 8\\\\0 &amp; 0 &amp; 0 &amp; 5/2\\end{bmatrix}$$ 最简阶梯矩阵 reduced echelon form$$\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 29 \\\\0 &amp; 1 &amp; 0 &amp; 16\\\\0 &amp; 0 &amp; 1 &amp; 3\\end{bmatrix}$$ Pivot PositonsA pivot position in a matrix A is a location in A that corresponds to a leading 1in the reduced echelon form of A. A pivot column is a column of A that containsa pivot position I think the leading entry is pivot postion.只是pivot postions是在最简阶梯矩阵的语境下的 Solutions of Linear SystemsThe variables $x_1$ and $x_2$ corresponding to pivot columns in the matrix are called basic variables.The other variable, $x_3$, is called a free variable. $$\\begin{cases}x_1 - 5 x_ 3 = 1 \\\\x_2 + x_3 = 4\\\\0 = 0\\end{cases}\\rightarrow\\begin{bmatrix}1 &amp; 0 &amp; -5 &amp; 1 \\\\0 &amp; 1 &amp; 1 &amp; 4\\\\0 &amp; 0 &amp; 0 &amp; 0\\end{bmatrix}$$ Augumented matrix has solution Existence and Uniqueness TheoremA linear system is consistent if and only if the rightmost column of the augmented matrix is not a pivot column—that is, if and only if an echelon form of the augmented matrix has no row of the form$$\\begin{bmatrix}0 &amp; \\cdots &amp;0 &amp; b\\end{bmatrix} with \\space b\\space nonzero$$If a linear system is consistent, then the solution set contains either (i) a unique solution, when there are no free variables, or (ii) infinitely many solutions, when there is at least one free variable. Vector EquationsVector in $R^n$if $n$ is a positive integer, $R^n$ denotes the collection of all lists (or ordered n-tuples) of $n$ real numbers, usually written as $n \\times 1$ column matrics, such as $$\\vec{a} = \\begin{bmatrix} u_1\\\\u_2\\\\\\cdots\\\\u_3\\end{bmatrix}$$ Linear CombinationsGiven vectors $\\vec{v_1}, \\vec{v_2}, \\cdots, \\vec{v_p}$ in $R^n$ and given scalars $c_1, c_2, \\cdots, c_p$, the vector $\\vec{y}$ defined by $$\\vec{y} = c_1\\vec{v_1} + \\cdots + c_p\\vec{v_p}$$ is called a linear combination of $\\vec{v_1}, \\cdots, \\vec{v_p}$ with weights $c_1, \\cdots, c_p$ Linear Combinations &amp; MatricsA vector equation $$x_1\\vec{a_1} + x_2\\vec{a_2} + \\cdots + x_n\\vec{a_n} = \\vec{b}$$ has the same solution set as the linear system whose augmented matrix is $$\\begin{bmatrix}\\vec{a_1} &amp; \\vec{a_2} &amp; \\cdots &amp; \\vec{a_n} &amp; \\vec{b}\\end{bmatrix}\\tag{5}$$ In particular, $\\vec{b}$ can be generated by a linear combination of $\\vec{a_1}\\cdots\\vec{a_n}$ if and only if there exists a solution to the linear system corresponding to the matrix(5) Span{$\\vec{v_1}, \\cdots, \\vec{v_p}$}Asking whether a vector $\\vec{b}$ is in Span{$\\vec{v_1}, \\cdots, \\vec{v_p}$} amounts to asking whether the vector equation $$x_1\\vec{v_1} + \\cdots + x_p\\vec{v_p} = \\vec{b}$$ has a solution, or, equivalently, asking whether the linear system with augmented matrix $$\\begin{bmatrix}\\vec{v_1} &amp; \\cdots &amp; \\vec{v_p} &amp; \\vec{b}\\end{bmatrix}$$ has a solution A Geometric Description of Span{$\\vec{v}$} and Span{$\\vec{u}, \\vec{v}$}Let $\\vec{v}$ be a nonzero vector in $R^3$. Then Span{$\\vec{v}$} is the set of all scalar multiples of $\\vec{v}$, which is the set of points on the line in $R^3$ through $\\vec{v}$ and $\\vec{0}$. See Figure 10. If $\\vec{u}$ and $\\vec{v}$ are nonzero vectors in $R^3$, with $\\vec{v}$ not a multiple of $\\vec{u}$, then Span{$\\vec{u},\\vec{v}$}is the plane in $R^3$ that contains $\\vec{u}$, $\\vec{v}$, and $\\vec{0}$. In particular, Span{$\\vec{u},\\vec{v}$} contains the line in $R^3$ through $\\vec{u}$ and $\\vec{0}$ and the line through $\\vec{v}$ and $\\vec{0}$. See Figure 11. The Matrix Equation $Ax = b$if $A$ is an $m \\times n$ matrix, with columns $\\vec{a_1}, \\cdots, \\vec{a_n}$, and if $\\vec{x}$ is in $R^n$, then the product of $A$ and $\\vec{x}$, denoted by $A\\vec{x}$, is the linear combination of the columns of $A$ using the corresponding entries in $\\vec{x}$ as weights; that is, $$A\\vec{x} =\\begin{bmatrix}\\vec{a_1} &amp; \\vec{a_2} &amp; \\cdots \\vec{a_n}\\end{bmatrix}\\begin{bmatrix}x_1\\\\ \\cdots \\\\ x_n\\end{bmatrix}=x_1\\vec{a_1}+x_2\\vec{a_2}+\\cdots+x_n\\vec{a_n}$$ 以下四种写法是等价的，全部转化为求增广矩阵的Solution： $$\\begin{cases}x_1 + 2x_2 - x_3 = 4\\\\-5x_2 + 3x_3 = 1 \\tag{1}\\end{cases}$$ $$x_1\\begin{bmatrix}1\\\\0\\end{bmatrix} +x_2\\begin{bmatrix}2\\\\-5\\end{bmatrix} +x_3\\begin{bmatrix}-1\\\\3\\end{bmatrix} =\\begin{bmatrix}4\\\\1\\end{bmatrix} \\tag{2}$$ $$\\begin{bmatrix}1 &amp; 2 &amp; -1\\\\0 &amp; -5 &amp; 3\\end{bmatrix}\\begin{bmatrix}x_1\\\\x_2\\\\x_3\\end{bmatrix}=\\begin{bmatrix}4 \\\\ 1\\end{bmatrix} \\tag{3}$$ $$\\begin{bmatrix}1 &amp; 2 &amp; -1 &amp; 4\\\\0 &amp; -5 &amp; 3 &amp; 1\\end{bmatrix} \\tag{4}$$ 计算机存储矩阵，用连续的空间存储提高效率To optimize a computer algorithm to compute $Ax$, the sequence of calculationsshould involve data stored in contiguous memory locations. The most widelyused professional algorithms for matrix computations are written in Fortran, alanguage that stores a matrix as a set of columns. Such algorithms compute $Ax$ asa linear combination of the columns of $A$. In contrast, if a program is written inthe popular language C, which stores matrices by rows, Ax should be computedvia the alternative rule that uses the rows of $A$ Solution sets of linear systemsHomogeneous Linear SystemsA system of linear equations is said to be homogeneous if it can be written in the form $A\\vec{x} = 0 $, where A is an $m \\times n$ matrix and $\\vec{0}$ is the zero vector in $R^m$. $\\vec{x} = \\vec{0}$ is a trivial solution. The homogeneous equation $A\\vec{x} = 0 $ has a nontrivial solution if and only if the equation has at least one free variable. For Example:$$\\begin{cases}3x_1 + 5x_2 - 4x_3 = 0\\\\-3x_1 - 2x_2 + 4x_3 = 0\\\\6x_1 + x_2 - 8x_3 = 0 \\tag{1}\\end{cases}$$Solution:$$\\begin{bmatrix}3 &amp; 5 &amp; -4 &amp; 0\\\\-3 &amp; 2 &amp; 4 &amp; 0\\\\6 &amp; 1 &amp; -8 &amp; 0\\end{bmatrix}\\sim\\begin{bmatrix}3 &amp; 5 &amp; -4 &amp; 0\\\\0 &amp; 3 &amp; 0 &amp; 0\\\\0 &amp; -9 &amp; 0 &amp; 0\\end{bmatrix}\\sim\\begin{bmatrix}3 &amp; 5 &amp; -4 &amp; 0\\\\0 &amp; 3 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0\\end{bmatrix}$$ Since $x_3$ is a free variable, $A\\vec{x} = \\vec{0}$ has nontrivial solutions, continue the row reduction of $\\begin{bmatrix}A &amp; \\vec{0}\\end{bmatrix}$ to reduced echelon form: $$\\begin{bmatrix}1 &amp; 0 &amp; -4/3 &amp; 0\\\\0 &amp; 3 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0\\end{bmatrix}\\rightarrow\\begin{matrix}x_1-\\frac{4}{3}x_3 = 0\\\\x_2 = 0\\\\0 = 0\\end{matrix}$$ the general solution of $A\\vec{x} = \\vec{0}$ has the form: $$\\vec{x} = \\begin{bmatrix}x_1\\\\x_2\\\\x_3\\end{bmatrix}=\\begin{bmatrix}\\frac{4}{3}x_3\\\\0\\\\x_3\\end{bmatrix}=x_3\\begin{bmatrix}\\frac{4}{3}\\\\0\\\\1\\end{bmatrix}=x_3\\vec{v},where\\space \\vec{v} = \\begin{bmatrix}\\frac{4}{3}\\\\0\\\\1\\end{bmatrix}$$ Geometrically, the solution set is a line through $\\vec{0}$ in $R^3$. See Figure1. Also, form as $\\vec{x} = x_3\\vec{v}$, we say that the solution is in parametric vector form. Solutions of Nonhomogeneous Linear SystemsFor example:$$\\begin{bmatrix}3 &amp; 5 &amp; -4 &amp; 7\\\\-3 &amp; -2 &amp; 4 &amp; -1\\\\6 &amp; 1 &amp; -8 &amp; -4\\end{bmatrix}\\sim\\begin{bmatrix}1 &amp; 0 &amp; -4/3 &amp; -1\\\\0 &amp; 1 &amp; 0 &amp; 2\\\\0 &amp; 0 &amp; 0 &amp; 0\\end{bmatrix}\\tag{2}$$the general solution has the form:$$\\vec{x} = \\begin{bmatrix}x_1\\\\x_2\\\\x_3\\end{bmatrix}=\\begin{bmatrix}-1+\\frac{4}{3}x_3\\\\2\\\\x_3\\end{bmatrix}=\\begin{bmatrix}-1\\\\2\\\\0\\end{bmatrix} + x_3\\begin{bmatrix}\\frac{4}{3}\\\\0\\\\1\\end{bmatrix}=\\vec{p} + x_3\\vec{v},where\\space \\vec{v} = \\begin{bmatrix}\\frac{4}{3}\\\\0\\\\1\\end{bmatrix},\\vec{p} = \\begin{bmatrix}-1\\\\2\\\\0\\end{bmatrix}$$ Summary： $$Homogeneous: \\vec{x} = t\\vec{v}\\\\Nonhomogeneous: \\vec{x} = \\vec{p} + t\\vec{v}\\\\From \\space Geometry：translation$$ the solution set of $A\\vec{x} = \\vec{b}$ is a line through $\\vec{p}$ parallel to the solution set of $A\\vec{x} = \\vec{0}$. Figure 6 illustrates the case in which there are two free variables, the solution set is a plane, not a line. Application of linear systemsNetwork FlowFor Example: The network in Figure 2 shows the traffic flow (in vehicles per hour) over several one-way streets in downtown Baltimore during a typical early afternoon.Determine the general flow pattern for the network. Solution: Intersection Flow in Flow out A 300+500 = $x_1 + x2$ B $x_2 + x4$ = 300 + $x_3$ C 100 + 400 = $x_4 + x5$ D $x_1 + x5$ = 600 $$列方程，解方程如下：\\begin{matrix}x_1 + x_2 = 800\\\\x_2 - x_3 + x4 = 300\\\\x_4 + x_5 = 500\\\\x1 + x5 = 600\\\\x_3 = 400\\end{matrix}\\sim\\begin{cases}x_1 = 600 - x_5 \\\\x_2 = 200 + x_5 \\\\x_3 = 400 \\\\x_4 = 500 - x_5\\\\x_5 is free\\end{cases}$$ Linear independence线性相关（有非零解）和线性无关（只有零解） An indexed set of vectors {${\\vec{v_1}, \\cdots, \\vec{v_p}}$} in $R^n$ is said to be linearly independent if the vector equation$$x_1\\vec{v_1} + x_2\\vec{v_2} + \\cdots + x_p\\vec{v_p} = \\vec{0}$$has only the trivial solution. The set {${\\vec{v_1}, \\cdots, \\vec{v_p}}$} is said to be linealy dependent if there exist weights $c_1, \\cdots, c_p$, not all zeros, such that$$c_1\\vec{v_1} + c_2\\vec{v_2} + \\cdots + c_p\\vec{v_p} = \\vec{0}$$ The columns of a matrix $A$ are linearly independent if and only if the equation $A\\vec{x} = \\vec{0}$has only the trivial solution, 当然可以通过观察发现两组向量是否线性相关,比如:$$\\vec{v_1} = \\begin{bmatrix}3\\\\1\\end{bmatrix},\\space\\vec{v_2} = \\begin{bmatrix}6\\\\2\\end{bmatrix}\\rightarrow\\vec{v_2} = 2\\vec{v_1},linear\\space dependent$$ A set of two vectors {$\\vec{v_1},\\vec{v_2}$} is linearly dependent if at least one of the vectors is a multiple of the other. The set is linearly independent if and only if neither of the vectors is a multiple of the other. Sets of Two or More Vectors 如果至少能找到一个向量是其他向量的线性组合，那么这个向量集就是线性相关的 If a set contains more vectors than there are entries in each vector, then the set is linearly dependent. That is, any set {$\\vec{v_1}, \\cdots, \\vec{v_p}$} in $R^n$ is linearly dependent if p &gt; n $$n= 3, p = 5,\\overbrace{\\begin{bmatrix}* &amp; * &amp; * &amp; * &amp; * \\\\* &amp; * &amp; * &amp; * &amp; * \\\\* &amp; * &amp; * &amp; * &amp; * \\\\\\end{bmatrix}}^{p}$$ $$\\begin{bmatrix}2\\\\1\\end{bmatrix},\\begin{bmatrix}4\\\\-1\\end{bmatrix},\\begin{bmatrix}-2\\\\2\\end{bmatrix}linearly-dependent, cause\\space three\\space vectors,but\\space two\\space entries\\space in \\space each \\space vector$$ Introduction to Linear TransformationIn Computer Graphics, $A\\vec{x}$ is not related to linear combination. We think the matrix $A$ as an object that “acts” on a vector $\\vec{v}$ by multiplication to produce a new vector called $A\\vec{x}$. Matrix Transformation$$\\vec{x}\\mapsto A\\vec{x}$$ A projection transformation if $A = \\begin{bmatrix}1 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 \\\\0 &amp; 0 &amp; 0\\end{bmatrix}$, then the transformation $\\vec{x}\\mapsto A\\vec{x}$ projects points in $R^3$ onto the $x_1x_2-plane$, because$$\\begin{bmatrix}x_1\\\\x_2\\\\x_3\\end{bmatrix}\\mapsto\\begin{bmatrix}1 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 \\\\0 &amp; 0 &amp; 0\\end{bmatrix}\\begin{bmatrix}x_1\\\\x_2\\\\x_3\\end{bmatrix}=\\begin{bmatrix}x_1\\\\x_2\\\\0\\end{bmatrix}$$ A shear transformation if $A = \\begin{bmatrix}1 &amp; 3 \\\\0 &amp; 1 \\\\\\end{bmatrix}$, the transformation $T:R^2\\rightarrow R^2$ defined by $T(\\vec{x}) = A\\vec{x}$ is called shear transformation, because $$\\begin{bmatrix}0\\\\2\\\\\\end{bmatrix}\\mapsto\\begin{bmatrix}1 &amp; 3 \\\\0 &amp; 1 \\\\\\end{bmatrix}\\begin{bmatrix}0\\\\2\\\\\\end{bmatrix}=\\begin{bmatrix}6\\\\2\\end{bmatrix}\\begin{bmatrix}2\\\\2\\end{bmatrix}\\mapsto\\begin{bmatrix}1 &amp; 3 \\\\0 &amp; 1\\end{bmatrix}\\begin{bmatrix}2\\\\2\\end{bmatrix}=\\begin{bmatrix}8\\\\2\\end{bmatrix}$$ The Matrix of Linear TransformationLet $T: R^n \\rightarrow R^m$ be a linear transformation. Then there exists a unique matrix $A$ such that $$T(\\vec{x}) = A\\vec{x},for\\space all\\space x \\space in R^n$$ In fact, $A$ is the $m \\times n$ matrix whose $j-th$ column is the vector $T(\\vec{e_j})$, where $\\vec{e_j}$ is the $j-th$ column of the identity matrix in $R^n$: $$A = \\begin{bmatrix} T(\\vec{e_1}) \\cdots T(\\vec{e_n})\\end{bmatrix}\\tag{3}$$ the matrxi in (3) is called the standard matrix for the linear transformation T. For example: The columns of $I_2 = \\begin{bmatrix}1 &amp; 0 \\\\ 0 &amp; 1\\end{bmatrix}$ are $\\vec{e_1} = \\begin{bmatrix}1 \\\\ 0\\end{bmatrix}$ and $\\vec{e_2} = \\begin{bmatrix}0 \\\\ 1\\end{bmatrix}$. Suppose T is a linear transformation from $R^2$ into $R^3$ such that $$T(\\vec{e_1}) = \\begin{bmatrix}5 \\\\ -7 \\\\ 2\\end{bmatrix}and \\spaceT(\\vec{e_2}) = \\begin{bmatrix}-3 \\\\ 8 \\\\ 0\\end{bmatrix}$$ with no additional information, find a formula for the image of an arbitrary $\\vec{x}$ in $R^2$ Solution：$$\\vec{x} = \\begin{bmatrix}x_1 \\\\ x_2 \\end{bmatrix}= x_1\\begin{bmatrix}1 \\\\ 0\\end{bmatrix} + x_2\\begin{bmatrix}0 \\\\ 1\\end{bmatrix}= x_1\\vec{e_1} + x_2\\vec{e_2}\\\\T(\\vec{x}) = x_1T(\\vec{e_1}) + x_2T(\\vec{e_2})= \\begin{bmatrix}5x_1 - 3x_2 \\\\ -7x_1+8x_2 \\\\ 2x_1+0\\end{bmatrix}\\\\T(\\vec{x}) = \\begin{bmatrix}T(\\vec{e_1}) &amp; T(\\vec{e_2})\\end{bmatrix}\\begin{bmatrix}x_1 \\\\ x_2\\end{bmatrix}= A\\vec{x}$$ A Rotation transformation 根据上文公式可以快速推导出2D旋转矩阵 $\\begin{bmatrix}1 \\\\ 0\\end{bmatrix}$ rotates into $\\begin{bmatrix}\\cos\\psi \\\\ \\sin\\psi\\end{bmatrix}$, and $\\begin{bmatrix}0 \\\\ 1\\end{bmatrix}$ rotates into $\\begin{bmatrix}-\\sin\\psi \\ \\cos\\psi\\end{bmatrix}$ so the rotation matrix is $\\begin{bmatrix}\\cos\\psi &amp; -\\sin\\psi\\\\ \\sin\\psi &amp; \\cos\\psi\\end{bmatrix}$ 同理，其他如Reflection， expansion…变换都可以根据基向量进行推导 Let $T: R^n \\rightarrow R^m$ be a linear transformation. Then $T$ is one-to-one if and only if the equation $T(\\vec{x}) = \\vec{0}$ has only the trivial solution. Linear models in business,science, and engineeringDifference Equations(差分方程)Several features of the system are each measured at discrete time intervals, producing a sequence of vectors $\\vec{x_0},\\vec{x_1},\\vec{x_2},\\cdots,\\vec{x_k}$ The entries in $\\vec{x_k}$ provide information about the state of the system at the time of the $k-th$ measurement. If there is a matrix A such that $\\vec{x_1} = A\\vec{x_0}, \\vec{x_2} = A\\vec{x_1}$ and, in general, $$\\vec{x_{k+1}} = A\\vec{x_k}, k = 0,1,2,…\\tag{5}$$ then (5) is called a linear difference equation (or recurrence relation). 比如, 一个地区的人口增长可以用这种模型简单的表示 思考：矩阵快速幂怎么求？首先考虑普通的快速幂: $$\\begin{aligned}4 ^ {11} &amp;= 4^{(1011)_2}\\\\&amp;= 4^{2^0}\\cdot4^{2^1}\\cdot4^{2^3}\\\\4^{2^1} &amp;= 4^{2^0} \\cdot 4^{2^0}\\\\4^{2^2} &amp;= 4^{2^1} \\cdot 4^{2^1}\\\\4^{2^3} &amp;= 4^{2^2} \\cdot 4^{2^2}\\end{aligned}$$ the c++ code is: 12345678910111213//get a^k mod pint qmi(int a, int k, int p){ int res = 1 % p; int t = a; //此时相当于a^(2^0) while(k) { if(k &amp; 1) res = (LL)res * t % p; t = (LL)t * t % p; k &gt;&gt;= 1; } return res;} 接下来考虑矩阵快速幂： for example: 如何快速计算Fibonacci的f(1000)？ $$Fibonacci\\\\f(0) = 0, f(1) = 1\\\\f(n) = f(n-1) + f(n-2), n &gt; 1\\\\建立矩阵方程如下：let \\space F(n) = \\begin{bmatrix}f(n)\\\\f(n+1)\\end{bmatrix}\\\\AF(n) = F(n+1)\\rightarrowA\\begin{bmatrix}f(n)\\\\ f(n+1)\\end{bmatrix} =\\begin{bmatrix}f(n+1)\\\\ f(n+2)\\end{bmatrix}\\rightarrowA = \\begin{bmatrix}0 &amp; 1\\\\1 &amp; 1\\end{bmatrix}\\RightarrowF(n) = A^nF(0), F(0) = \\begin{bmatrix}0\\\\1\\end{bmatrix}$$ 1234567891011121314//get A^k * F_0 % p//示例使用左乘int qmi(Matrix A, int k, int p, Vector F_0){ Vector res = F_0 % p; Matrix t = A; //A^(2^0) while(k) { if(k &amp; 1) res = t * res % p; t = t * t % p; k &gt;&gt;=1; } return res;}","link":"/Math/Linear-Algebra/C1-Linear-Equation-in-Linear-Algebra/"},{"title":"Lighting-Shading-Texture","text":"Keywords: Surface Shading, Texture mapping How to Understand Shading?How to understand shading? Just like everything does in the real world, all the scenes we see are under different ligths : the sun, the lamp, the flash light etc. Shading is kind of a technique that has a significant relationship with lights and will present the colorful drawings to us at last. Surface shading means the surface is ‘painted’ with lights, it’s a process of applying a material to an object. The Standard Local Lighting ModelI bet that you have heard the term: BRDF(Bidirectional Reflectance Distribution Function) which seems to have inextricable linkes to the Standard Lighting Model. Yes,BRDF will appear in PBS(Physically Based Shading) which is used to make more realistic modeling presenting the reactions between lights and materials. As for Standard Local Lighting Model, they can be considered as simplified versions of PBS, they are empirical models, but they are easier to understand. The Standard Lighting Equation OverviewThe Standard Lighting Model only cares about direct light (direct reflection).Lights are special entities without any corresponding geometry,and are simulated as if the light were emitting from a sight point. The rendering equation is an equation for the radiance outgoing from a point in any particular direction,the only outgoing direction that mattered in those days were the directions that pointed to the eye. Why say that? Because you know the real world doesn’t work like this where the light may reflect for dozens of times and the process is really complicated, the cost is also a luxury that could not yet be afforded. The basic idea is to classify coming into the eye into four distinct categories, each of which has a unique method for calculating its contribution. The four categories are : Emissive contribution,denoted as $c_{emis}$. It tells the amount of radiance emitted directly from the surface in the given direction. Note that without global illumination techniques,these surfaces do not actually light up anything(except themselves). Specular contribution,denoted as $c_{spc}$. It accounts for light incident directly from the light source that is scattered preferentially in the direction of a perfect “mirror bounce”. Diffuse contribution,denoted as $c_{diff}$. It accounts for light incident directly from the light source that is scattered in every direction evenly. Ambient contribution,denoted as $c_{amb}$. It is a fudge factor to account for all indirect light. The Ambient and Emmisive ComponentsTo model light that is reflected more than one time before it enters the eye,we can use a very crude approximation known as “ambient light”. The ambient portion of the lighting equation depends only on the properties of materials and an ambient lighting value,which is often a global value used for the entire scene.$$c_{amb} = g_{amb} \\cdot m_{amb}\\tag{1}$$The factor $m_{amb}$ is the material’s “ambient color”. This is almost always the same as the diffuse color (which is often defined using texture map). The other factor,$g_{amb}$,is the ambient light value. Somtimes a ray of light travels directly from the light source to the eye,without striking any surface in between. The standard lighting equation accounts for such rays by assigning a material an emissive color. For example,when we render the surface of the light bulb,this surface will probably appear very bright,even if there’s no other light in the scene,because the light bulb is emitting light. In many situations,the emissive contribution doesn’t depend on environmental factor; it is simply the emissive color of the material.$$c_{emis} = m_{emis}\\tag{2}$$ The Diffuse ComponentFor diffuse lighting, the location of the viewer is not relevant,since the reflections are scattered randomly, and no matter where we position the camera,it is equally likely that a ray will be sent our way. But the direction if incidence l,which is dictated by the position of the light source relative to the surface, is important. Diffuse lighting obeys Lambert’s law: the intensity of the reflected light is proportional to the cosine of the angle between the surface normal and the rays of light. We calculate the diffuse component according to Lambert’s Law:$$c_{diff} = c_{light} \\cdot m_{diff} \\cdot max(0,n \\cdot l)\\tag{3}$$as before, n is the surface normal and l is a unit vector that points towards the light source. The factor $m_{diff}$ is the material’s diffuse color, which is the value that most people think of when they think of the “color” of an object. The diffuse material color often comes from a texture map. The diffuse color of the light source is $c_{light}$. On thing needs attention, that is the max(), because we need to prevent the dot result of normal and light negative, we use $max(0,n \\cdot l)$, so the object won’t be lighted by the rays from it’s back. The Specular ComponentThe specular component is what gives surfaces a “shiny” appearance. If you don’t understand what a specular is, think about the professional term in animes: Now let’s see how the standard model calculates the specular contribution. For convenience,we assume that all of these vectors are unit vectors. n is the local outward-pointing surface normal v points towards the viewer. l points towards the light source. r is the reflection vector, which is the direction of a “perfect mirror bounce.” It’s the result of reflecting l about n. $\\theta$ is the angle between r and v. Of the four vectors, you can see the reflection vector can be computed by The Phong Model for specular reflection is :$$c_{spec} = c_{light} \\cdot m_{spec} \\cdot max(0,v \\cdot r)^{m_{gls}}\\tag{4}$$$$r = 2(n \\cdot l)n-l$$ $m_{gls}$ means the glossiness of the material,also known as the Phong exponent, specular exponent, or just as the material shininess. This controls how wide the “hotspot” is - a smaller $m_{gls}$ produces a larger, more gradual falloff from the hotspot,and a larger $m_{gls}$ produces a tight hotspot with sharp falloff. $m_{spec}$ is related to “shininess”, it represents the material’s specular color. While $m_{gls}$ controls the size of the hotspot, $m_{spec}$ controls its intensity and color. $c_{light}$ is essentially the “color” of the light, which contains both its color and intensity. But!!We usually use Blinn Phong Model instead of Phong Model. The Blinn phong model can be faster to implement in hardware than the Phong model, if the viewer and light source are far enough away from the object to be considered a constant,since then h is a constant and only needs to be computed once. But when v or l may not be considered constant, the Phong model calculation might be faster.The Blinn Phong Model for specualr reflection is :$$c_{spec} = c_{light} \\cdot m_{spec} \\cdot max(0,n \\cdot h)^{m_{gls}}\\tag{4}$$$$h = \\frac{v + l}{|v + l|}$$ In real coding, vector in the above (1)(2)(3)(4) should be unit vector Limitations of the Standard ModelWhy learn about this ancient history? First, it isn’t exactly ancient history, it’s alive and well. Second,the current local lighting model is one that content creators can understand and use. A final reason to learn the standard lighting model is becausemany newer models bear similarities to the standard model, and you cannotknow when to use more advanced lighting models without understandingthe old standard. Since Blinn Phong Model contains all the components above,so we call the it Blinn-Phong. Actually, there are several important physical phenomena not properly captured by the Blinn-Phong model. Such as Fresnel reflectance. (:) We’ll discuss this PBS part in the Appendix). Flat &amp; Gouraud ShadingThis part is about the Shading Frequencies. Are you confused? If not, it’s impossible. Because I’m confused at the first time learning and the second time learning. But now, I got it. So come with me. On modern shader-based hardware, lighting calculations are usually done on a per-pixel basis. By this we mean that for each pixel, we determine a surface normal (whether by interpolating the vertex normal across the face or by fetching it from a bump map), and then we perform the full lighting equation using this surface normal. This is per-pixel lighting, and the technique of interpolating vertex normals across the face is sometimes called Phong shading, not to be confused with the Phong calculation for specular reflection. The alternative to Phong shading is to perform the lighting equation less frequently (per face, or per vertex). These two techniques are known as flat shading and Gouraud shading, respectively. Flat shading is almost never used in practice except in software rendering. This is because most modern methods of sending geometry efficiently to the hardware do not provide any face-level data whatsoever. Gouraud shading, in contrast, still has some limited use on some platforms. Some important general principles can be gleaned from studying these methods, so let’s examine their results. Phong shading ≠ Phong Reflection Model ≠ Blinn Phong Reflection Model The table below can list differences among them. per-pixel lighting per-vertex lighting per-face lighting Phong shading Gouraud shading Flat shading Interpolate normal vectors across each triangle Interpolate colors from vertices across triangle Triangle face is flat — one normal vector Compute full shading model at each pixel Each vertex has a normal vector Not good for smooth surfaces # Mostly used is phong shading Talk is cheap, show me the code. Here’s a code (from[3]) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//per-pixel lightingShader \"Unity Shaders Book/Chapter 6/Blinn-Phong Use Built-in Functions\" { Properties { _Diffuse (\"Diffuse\", Color) = (1, 1, 1, 1) _Specular (\"Specular\", Color) = (1, 1, 1, 1) _Gloss (\"Gloss\", Range(1.0, 500)) = 20 } SubShader { Pass { Tags { \"LightMode\"=\"ForwardBase\" } CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"Lighting.cginc\" fixed4 _Diffuse; fixed4 _Specular; float _Gloss; struct a2v { float4 vertex : POSITION; float3 normal : NORMAL; }; struct v2f { float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float4 worldPos : TEXCOORD1; }; v2f vert(a2v v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); // Use the build-in funtion to compute the normal in world space o.worldNormal = UnityObjectToWorldNormal(v.normal); o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } fixed4 frag(v2f i) : SV_Target { fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; fixed3 worldNormal = normalize(i.worldNormal); // Use the build-in funtion to compute the light direction in world space // Remember to normalize the result fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos)); fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * max(0, dot(worldNormal, worldLightDir)); // Use the build-in funtion to compute the view direction in world space // Remember to normalize the result fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos)); fixed3 halfDir = normalize(worldLightDir + viewDir); fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss); return fixed4(ambient + diffuse + specular, 1.0); } ENDCG } } FallBack \"Specular\"} The result is : Light SourcesIf you have used Unity, you won’t forget different kinds of lights. Standard Abstract Light Types A point light source represents light that emanates from a single point outward in all directions. Point lights are also called omni lights (short for “omnidirectional”) or spherical lights.A point light has a position and color, which controls not only the hue of the light, but also its intensity. Point lights can be used to represent many common light sources, such as light bulbs, lamps, fires, and so forth. point light = omni light = spherical light A spot light is used to represent light from a specific location in a specific direction. These are used for lights such as flashlights, headlights, and of course, spot lights~ As for A conical spot light, it has a circular “bottom”, the width of the cone is defined by a falloff angle(not to be confused with the falloff distance). Also, there is an inner angle that measures the size of the hotspot. A directional light represents light emanating from a point in space sufficiently far away that all the rays of light involved in lighting the scene (or at least the object we are currently considering) can be considered as parallel. Directional lights usually do not have a position, at least as far as lighting calculations are concerned, and they usually do not attenuate. Like the sun and moon in our real world. Directional light = parallel light = distant light An area light is only useful in bake. So we don’t talke about it here. Here’s intuitional effects among the lights. Light AttenuationIn the real world, the intensity of a light is inversely proportional to the square of the distance between the light and the object, as$$\\frac{i_1}{i_2} = (\\frac{d_2}{d_1})^2\\tag{1}$$where i is the radiant flux (the radiant power per unit area) and d is the distance. This part will be mentioned again in the RayTracing article, it’s about Radiometry. Here you just need to know that the final amount of emitted light is obtained by multiplying the light color by its intensity: light amount = light color * light intensity Actually,I haven’t used light-falloff in my coding. Also this blog is for the novices, so let’s continue with a simple practice and finish this part. Just rememeber that this is the very primary part. Talk is cheap, show me the code.(frome[3]) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161Shader \"Unity Shaders Book/Chapter 9/Forward Rendering\" { Properties { _Diffuse (\"Diffuse\", Color) = (1, 1, 1, 1) _Specular (\"Specular\", Color) = (1, 1, 1, 1) _Gloss (\"Gloss\", Range(8.0, 256)) = 20 } SubShader { Tags { \"RenderType\"=\"Opaque\" } Pass { // Pass for ambient light &amp; first pixel light (directional light) Tags { \"LightMode\"=\"ForwardBase\" } CGPROGRAM // Apparently need to add this declaration //该指令可以保证我们的shader中使用的光照衰减等光照变量可以被正确赋值 #pragma multi_compile_fwdbase #pragma vertex vert #pragma fragment frag #include \"Lighting.cginc\" fixed4 _Diffuse; fixed4 _Specular; float _Gloss; struct a2v { float4 vertex : POSITION; float3 normal : NORMAL; }; struct v2f { float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; }; v2f vert(a2v v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.worldNormal = UnityObjectToWorldNormal(v.normal); o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz; return o; } fixed4 frag(v2f i) : SV_Target { fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz); fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * max(0, dot(worldNormal, worldLightDir)); fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz); fixed3 halfDir = normalize(worldLightDir + viewDir); fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss); fixed atten = 1.0; return fixed4(ambient + (diffuse + specular) * atten, 1.0); } ENDCG } Pass { // Pass for other pixel lights Tags { \"LightMode\"=\"ForwardAdd\" } Blend One One CGPROGRAM // Apparently need to add this declaration //该指令保证我们在additional pass 中访问到正确的光照变量 #pragma multi_compile_fwdadd #pragma vertex vert #pragma fragment frag #include \"Lighting.cginc\" #include \"AutoLight.cginc\" fixed4 _Diffuse; fixed4 _Specular; float _Gloss; struct a2v { float4 vertex : POSITION; float3 normal : NORMAL; }; struct v2f { float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; }; v2f vert(a2v v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.worldNormal = UnityObjectToWorldNormal(v.normal); o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz; return o; } fixed4 frag(v2f i) : SV_Target { fixed3 worldNormal = normalize(i.worldNormal); //如果当前处理的光源类型是平行光,因为平行光没有固定的位置 #ifdef USING_DIRECTIONAL_LIGHT fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz); //如果是点光源或者聚光灯，他们的位置是 #else fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz - i.worldPos.xyz); #endif fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * max(0, dot(worldNormal, worldLightDir)); fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz); fixed3 halfDir = normalize(worldLightDir + viewDir); fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss); //如果是平行光，衰减值为1 #ifdef USING_DIRECTIONAL_LIGHT fixed atten = 1.0; #else //if point light,transform the vertex position from world spact to light space //sample the texture to get the Attenuation value //如果是点光源，把顶点坐标从世界空间到光线空间 #if defined (POINT) float3 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, 1)).xyz; fixed atten = tex2D(_LightTexture0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL; //if spot light #elif defined (SPOT) float4 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, 1)); fixed atten = (lightCoord.z &gt; 0) * tex2D(_LightTexture0, lightCoord.xy / lightCoord.w + 0.5).w * tex2D(_LightTextureB0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL; #else fixed atten = 1.0; #endif #endif return fixed4((diffuse + specular) * atten, 1.0); } ENDCG } } FallBack \"Specular\"} If you want to know the rendering order,you can use the Frame Debug, this tool is really useful. I think as the study goes further, this part will be mentioned again. Also this is my learning curve, maybe it matches you too. So go on with my articles. Texture MappingFinally, here comes the texture mapping!I am already gearing up and eager to try. Cuz I really want to overview the shadow mapping and opacity blend again. And there are too many things cannot learn forward without the knowledge of texture. What is a Texture?There is much more to the appearance of an object than its shape. Different objects are different colors and have different patterns on their surface. One simple yet powerful way to capture these qualities is through texture mapping. A texture map is a bitmap image that is “pasted” to the surface of an object. bitmap image is pixel-image, on the contrary, vector-image So a texture map is just a regular bitmap that is applied onto the surface of a model. Exactly how does this work? The key idea is that, at each point on the surface of the mesh, we can obtain texture-mapping coordinates, which define the 2D location in the texture map that corresponds to this 3D location. Traditionally, these coordinates are assigned the variables (u,v), where u is the horizontal coordinate and v is the vertical coordinate; thus texture-mapping coordinates are often called UV coordinates or simply UVs. On thing needs attention : The origin is in the upper left-hand corner of the image, which is the DirectX-style convention, or in the lower left-hand corner, the OpenGL conventions.In unity, the powerful engine has solved the problem for us, unity use uniform left-hand corner as OpenGL. Although bitmaps come in different sizes, UV coordinates are normalized such that the mapping space ranges from 0 to 1 over the entire width(u) or height (v) of the image, rather than depending on the image dimensions. We typically compute or assign UV coordinates only at the vertex level, and the UV coordinates at an arbitratry interior position on a face are obtained through interpolation (:) See in Appendix) So the pseudo-code of UV mapping should be: 12345//c++for each rasterized screen sample (x,y): //sample (x,y)-usually a pixel's center (u,v) = evaluate texture coordinate at (x,y) //using barycentric coordinates texcolor = texture.sample(u,v); set sample’s color to texcolor; //usually the diffuse albedo Kd(recall the Blinn-Phong reflectance model) Texture MagnificationUV coordinates outside of the range [0,1] are allowed, and in fact are quite useful. Such coordinates are interpreted in a variety of ways. The most common addressing modes (Wrap Mode) are repeat (also known as tile or wrap) and clamp. When repeating is used, the integer portion is discarded and only the fractional portion is used, causing the texture to repeat. Under clamping, when a coordinate outside the range [0,1] is used to access a bitmap, it is clamped in range. This has the effect of streaking the edge pixels of the bitmap outwards. The mesh in both cases is identical: a single polygon with four vertices. And the meshes have identical UV coordinates. The only difference is how coordinates outside the [0,1] range are interpreted. See Fig17. If you have used Unity, this is not strange to you. See the example below(from[3]). The shader code on the materail of the Quad is : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Shader \"Unity Shaders Book/Chapter 7/Texture Properties\" { Properties { _MainTex (\"Main Tex\", 2D) = \"white\" {} } SubShader { Pass { Tags { \"LightMode\"=\"ForwardBase\" } CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"Lighting.cginc\" sampler2D _MainTex; float4 _MainTex_ST; struct a2v { float4 vertex : POSITION; float4 texcoord : TEXCOORD0; }; struct v2f { float4 position : SV_POSITION; float2 uv : TEXCOORD0; }; v2f vert(a2v v) { v2f o; // Transform the vertex from object space to projection space o.position = UnityObjectToClipPos(v.vertex); //注意这里的v是模型空间中就定义好的纹理坐标 //v.texcoord应该是0-1之间,如果在面板上更改缩放值和偏移量，就会改动o.uv不在0-1之间 //o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw; o.uv = TRANSFORM_TEX(v.texcoord, _MainTex); return o; } fixed4 frag(v2f i) : SV_Target { //根据uv值对纹理进行采样 fixed4 c = tex2D(_MainTex, i.uv); return fixed4(c.rgb, 1.0); } ENDCG } } FallBack \"Diffuse\"} I think you have noticed the code //o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw; Look at the gif below, _MainTex_ST.xy means Tiling, _MainTex_ST.zw means offset. Also, I think you have noticed that there is Mipmap &amp; FilterMode properties in the panel of Fig17-1, what’s the meaning of these? You see that in Unity, the png is 512*512, it matches the Quad just in time. What if the texture(png) is too small? It’s easy to imagine, that you have an image, but the object is too giant, you need some methods to let the texture ‘pasted’ on the object surface without low resolution/distortion. Here I want to infer Bilinear Interpolation (:) see it in the Appendix) Then What if the texture(png) is too large? Here comes Mipmap (This part is a little hard for me. so Jump over it and later back..) Different Types Texture MappingThere are too many types of texture mapping. Bump MappingBump mapping is a general term that can refer to at least two different methods of controlling the surface normal per texel. A height map is a grayscale map, in which the intensity indicates the local “elevation” of the surface. Lighter colors indicate portions of the surface that are “bumped out,” and darker colors are areas where the surface is “bumped in.” Height maps are attractive because they are very easy to author, but they are not ideal for real-time purposes because the normal is not directly available; instead, it must be calculated from the intensity gradient. (We wil talk about it in Displacement Mapping) A bump map, which is very common nowadays, is Normal Mapping. Normal MappingIn a normal map, the coordinates of the surface normal are directly encoded in the map. How could a bump map save the surface normal of the object? Of course, the color. The most basic way is to encode x, y, and z in the red, green, and blue channels. Since the normal vector is bounded in [-1,1],and the color channel component is bounded in [0,1], so there should be a principle:$$pixel = \\frac{normal + 1}{2}$$Seems easy~ The bump map storse the normal vectors in model space in terms of pixels(rgb). Voila! If only it were that easy. Real-world objects exhibit a great deal of symmetry and self-similarity, and patterns are often repeated. For example, a box often has similar bumps and notches on more than one side. Because of this, it is currently a more efficient use of the same amount of memory (and artist time) to increase the resolution of the map and reuse the same normal map (or perhaps just portions of it) on multiple models (or perhaps just on multiple places in the same model). Of course, the same principle applies to any sort of texture map, not just normal maps. But normal maps are different in that they cannot be arbitrarily rotated or mirrored because they encode a vector. Imagine using the same normal map on all six sides of a cube. While shading a point on the surface of the cube, we will fetch a texel from the map and decode it into a 3D vector. A particular normal map texel on the top will produce a surface normal that points in the same direction as that same texel on the bottom of the cube, when they should be opposites! We need some other kind of information to tell us how to interpret the normal we get from the texture, and this extra bit of information is stored in the basis vectors. So there comes the Tangent Space.In tangent space, +z points out from the surface; the +z basis vector is actually just the surface normal n. The x basis vector is known as the tangent vector, which we’ll denote t, and it points in the direction of increasing t in texture space. Similarly, the y basis vector, known as the binormal and denoted here as b, corresponds to the direction of increasing b, although whether this motion is “up” or “down” in the texture space depends on the conventions for the origin in (t,b) space, which can differ, as we discussed earlier. The coordinates for the tangent and binormal are given in model space. And how to calculate basis vectors as the average of adjacent triangle normals?Here’s the formula &amp; code(from[1])We are given a triangle with vertex positions $p_0 = (x_0 ,y_0 ,z_0 ), p_1 = (x_1 ,y_1 ,z_1 ), and p_2 = (x_2 ,y_2 ,z_2),$ and at those vertices we have the UV coordinates $(u_0 ,v_0 ), (u_1 ,v_1 ), and (u_2 ,v_2 ).$$$q_1 = p_1 − p_0 , s_1 = u_1 − u_0 , t_1 = v_1 − v_0$$$$q_2 = p 2 − p_0 , s_2 = u_2 − u_0 , t_2 = v_2 − v_0.$$$$tangent = t_2q_1 - t_1q_2 , binormal = -s_2q_1 + s_1q_2$$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//c++struct Vertex { Vector3 pos ; float u, v ; Vector3 normal ; Vector3 tangent ; float det ; // determinant of tangent transform. (−1 i f mirrored )};struct Triangle { int vertexIndex [3];};struct TriangleMesh { int vertexCount ; Vertex ∗vertexList ; int triangleCount ; Triangle ∗ triangleList ; void computeBasisVectors ( ) { // Note: we assume vertex normals are valid Vector3 ∗tempTangent = new Vector3 [ vertexCount ]; Vector3 ∗tempBinormal = new Vector3 [ vertexCount ]; // F i r s t clear out the accumulators for ( int i = 0 ; i &lt; vertexCount ; ++i ) { tempTangent [i].zero ( ) ; tempBinormal [i].zero ( ) ; } // Average in the basis vectors for each face // into i t s neighboring vertices for ( int i = 0 ; i &lt; triangleCount ; ++i ) { // Get shortcuts const Triangle &amp;tri = triangleList [ i ]; const Vertex &amp;v0 = vertexList [ tri.vertexIndex [0]]; const Vertex &amp;v1 = vertexList [ tri.vertexIndex [1]]; const Vertex &amp;v2 = vertexList [ tri.vertexIndex [2]]; // Compute intermediate values Vector3 q1 = v1.pos − v0.pos ; Vector3 q2 = v2.pos − v0.pos ; float s1 = v1.u − v0.u; float s2 = v2.u − v0.u; float t1 = v1.v − v0.v ; float t2 = v2.v − v0.v ; // Compute basis vectors for this triangle Vector3 tangent = t2∗q1 − t1∗q2; tangent.normalize ( ) ; Vector3 binormal = −s2∗q1 + s1∗q2; binormal.normalize ( ) ; // Add them into the running totals for neighboring verts for ( int j = 0 ; j &lt; 3 ; ++j ) { tempTangent [ tri.vertexIndex [ j ]] += tangent ; tempBinormal [ tri.vertexIndex [ j ]] += binormal ; } } // Now f i l l in the values into the vertices for ( int i = 0 ; i &lt; vertexCount ; ++i ) { Vertex &amp;v = vertexList [ i ]; Vector3 t = tempTangent [ i ]; // Ensure tangent is perpendicular to the normal. // (Gram−Schmit ) , then keep normalized version t −= v.normal ∗ dot (t,v.normal ) ; t.normalize ( ) ; v.tangent = t ; // Figure out i f we’ re mirrored if ( dot ( cross ( v.normal , t ) , tempBinormal [ i ]) &lt; 0.0 f ) { v.det = −1.0f ; // we’ re mirrored } else { v.det = +1.0 f ; // not mirrored } } // Clean up delete [] tempTangent ; delete [] tempBinormal ; }}; In unity, you can calculate the lighting model in the world space with bump textures.Here an example.(from[3]) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697Shader \"Unity Shaders Book/Chapter 7/Normal Map In World Space\" { Properties { _Color (\"Color Tint\", Color) = (1, 1, 1, 1) _MainTex (\"Main Tex\", 2D) = \"white\" {} _BumpMap (\"Normal Map\", 2D) = \"bump\" {} _BumpScale (\"Bump Scale\", Float) = 1.0 _Specular (\"Specular\", Color) = (1, 1, 1, 1) _Gloss (\"Gloss\", Range(8.0, 256)) = 20 } SubShader { Pass { Tags { \"LightMode\"=\"ForwardBase\" } CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"Lighting.cginc\" fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; sampler2D _BumpMap; float4 _BumpMap_ST; float _BumpScale; fixed4 _Specular; float _Gloss; struct a2v { float4 vertex : POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; float4 texcoord : TEXCOORD0; }; struct v2f { float4 pos : SV_POSITION; float4 uv : TEXCOORD0; float4 TtoW0 : TEXCOORD1; float4 TtoW1 : TEXCOORD2; float4 TtoW2 : TEXCOORD3; }; v2f vert(a2v v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw; o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw; float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz; fixed3 worldNormal = UnityObjectToWorldNormal(v.normal); fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz); fixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w; // Compute the matrix that transform directions from tangent space to world space // Put the world position in w component for optimization o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x); o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y); o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z); return o; } fixed4 frag(v2f i) : SV_Target { // Get the position in world space float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w); // Compute the light and view dir in world space fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos)); fixed3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos)); // Get the normal in tangent space fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw)); bump.xy *= _BumpScale; bump.z = sqrt(1.0 - saturate(dot(bump.xy, bump.xy))); // Transform the narmal from tangent space to world space bump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz, bump), dot(i.TtoW2.xyz, bump))); fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo; fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(bump, lightDir)); fixed3 halfDir = normalize(lightDir + viewDir); fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(bump, halfDir)), _Gloss); return fixed4(ambient + diffuse + specular, 1.0); } ENDCG } } FallBack \"Specular\"} Displacement MappingA height map (or true displacement map) can be easily painted in Photoshop; Since normal map is clear , displacement is not hard for you.A displacement map actually changes the geometry using a texture. A common simplification is that the displacement will be in the direction of the surface normal. $$p\\prime = p + f(p)n.$$ Environment MappingOften we want to have a texture-mapped background and for objects to have specular reflections of that background. This can be accomplished using environment maps; There are many ways to store environment maps. Here is the most common method cube map. If you have used Unity, then you’ll be familiar with cube map, yes, the sky box~ In ideal cases, we want to generate the corresponding cube map for the objects of different positions in the scene. So the smart way is to write scripts. Here’s an example 123456789101112131415161718192021222324252627282930313233using UnityEngine;using UnityEditor;using System.Collections;public class RenderCubemapWizard : ScriptableWizard { public Transform renderFromPosition; public Cubemap cubemap; void OnWizardUpdate () { helpString = \"Select transform to render from and cubemap to render into\"; isValid = (renderFromPosition != null) &amp;&amp; (cubemap != null); } void OnWizardCreate () { // create temporary camera for rendering GameObject go = new GameObject( \"CubemapCamera\"); go.AddComponent&lt;Camera&gt;(); // place it on the object go.transform.position = renderFromPosition.position; // render into cubemap go.GetComponent&lt;Camera&gt;().RenderToCubemap(cubemap); // destroy temporary camera DestroyImmediate( go ); } [MenuItem(\"GameObject/Render into Cubemap\")] static void RenderCubemap () { ScriptableWizard.DisplayWizard&lt;RenderCubemapWizard&gt;( \"Render cubemap\", \"Render!\"); }} Shadow MapsHere comes the shadow map. Opacity Blending Appendix:PBSThis part will be explained in First-Met-With-RayTracing. InterpolationBefore learning CG, I couldn’t understand the term interpolation. Now it’s time write something about it.There are many interpolation methods, today I want to introduce a common method, called Barycentric Coordinates - used in Interpolation Across Triangles. If you have read the above the paragraphs carefully, you can see the barycentric coordinates method has appeared before. Why do we want interplate? Specify values at vertices Obtain smoothly varying values across triangles What do we want to interpolate? Texture coordinates, colors, normal vectors, … Barycentric Coordinates: Formulas $$\\alpha = \\frac{-(x-x_B)(y_C - y_B) + (y-y_B)(x_C-x_B)}{-(x_A-x_B)(y_C-y_B) + (y_A-y_B)(x_C-x_B)}\\tag{Barycentric Coordinates: Formulas}$$$$\\beta = \\frac{-(x-x_C)(y_A-y_C) + (y-y_C)(x_A-x_C)}{-(x_B-x_C)(y_A-y_C) + (y_B-y_C)(x_A-x_C)}$$$$\\gamma = 1 - \\alpha - \\beta$$ Using Barycentric Coordinates talk is cheap, show me the code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//c++static std::tuple&lt;float, float, float&gt; computeBarycentric2D(float x, float y, const Vector4f* v){ float alpha = (x*(v[1].y() - v[2].y()) + (v[2].x() - v[1].x())*y + v[1].x()*v[2].y() - v[2].x()*v[1].y()) / (v[0].x()*(v[1].y() - v[2].y()) + (v[2].x() - v[1].x())*v[0].y() + v[1].x()*v[2].y() - v[2].x()*v[1].y()); float beta = (x*(v[2].y() - v[0].y()) + (v[0].x() - v[2].x())*y + v[2].x()*v[0].y() - v[0].x()*v[2].y()) / (v[1].x()*(v[2].y() - v[0].y()) + (v[0].x() - v[2].x())*v[1].y() + v[2].x()*v[0].y() - v[0].x()*v[2].y()); float gamma = (x*(v[0].y() - v[1].y()) + (v[1].x() - v[0].x())*y + v[0].x()*v[1].y() - v[1].x()*v[0].y()) / (v[2].x()*(v[0].y() - v[1].y()) + (v[1].x() - v[0].x())*v[2].y() + v[0].x()*v[1].y() - v[1].x()*v[0].y()); return {alpha,beta,gamma};}//we all know that color,vertex position,normal are Vector3fstatic Eigen::Vector3f interpolate(float alpha, float beta, float gamma, const Eigen::Vector3f&amp; vert1, const Eigen::Vector3f&amp; vert2, const Eigen::Vector3f&amp; vert3, float weight){ return (alpha * vert1 + beta * vert2 + gamma * vert3) / weight;}//uv coordinates are Vector2fstatic Eigen::Vector2f interpolate(float alpha, float beta, float gamma, const Eigen::Vector2f&amp; vert1, const Eigen::Vector2f&amp; vert2, const Eigen::Vector2f&amp; vert3, float weight){ auto u = (alpha * vert1[0] + beta * vert2[0] + gamma * vert3[0]); auto v = (alpha * vert1[1] + beta * vert2[1] + gamma * vert3[1]); u /= weight; v /= weight; return Eigen::Vector2f(u, v);}//here's the rasterization processvoid rasterization(Triangle &amp;t){ ...find the bounding box of t for(int x = int(x_min); x &lt; int(x_max)+1; x++) { for(int y = int(y_min); y&lt; int(y_max)+1;y++) { if(insideTriangle(float(x) + 0.5, float(y) + 0.5, t)) { //get alpha,beta,gamma auto[alpha, beta, gamma] = computeBarycentric2D(x, y, t.v); float Z = 1.0 / (alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w()); //interpolate depth float zp = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w(); zp *= Z; //if pass the depth test auto interpolated_color = interpolate(alpha,beta,gamma,t.color[0],t.color[1],t.color[2],1); auto interpolated_normal = interpolate(alpha,beta,gamma,t.normal[0],t.normal[1],t.normal[2],1); auto interpolated_texcoords = interpolate(alpha,beta,gamma,t.tex_coords[0],t.tex_coords[1],t.tex_coords[2],1); ... } } }} Bilinear InterpolationSince we mentioned bilinear interpolation in the texture magnificient part. So let’s go straight. Step1. We want to sample texture f(x,y) at red point, black points indicate texture sample locations. Step2. Take 4 nearest sample locations, with texture values as labeled. Step3. Calculate fractional offsets,(s,t) Step4. $$lerp(x,v_0,v_1) = v_0 + x(v_1 - v_0)\\tag{Linear interpolation (1D)}$$$$u_0 = lerp(s,u_{00},u_{10})$$$$u_1 = lerp(s,u_{01},u_{11})\\tag{Two helper lerps}$$$$f(x,y) = lerp(t,u_0,u_1)\\tag{Final vertical lerp, to get result}$$ talk is cheap, show me the code 1234567891011121314151617181920212223242526272829303132333435//c++/opencvEigen::Vector3f getColor(float u, float v) { auto u_img = u * (width-1); auto v_img = (1 - v) * (height-1); auto color = image_data.at&lt;cv::Vec3b&gt;(v_img, u_img); return Eigen::Vector3f(color[0], color[1], color[2]); } //if the texture image is low-pixels, then u_img &amp; v_img will not be int(ideally case). Eigen::Vector3f getColorBilinear(float u,float v) { auto u_img = u * (width-1); auto v_img = v * (height-1); Eigen::Vector2f u00(std::floor(u_img)*1.f,std::floor(v_img)*1.f); Eigen::Vector2f u10(std::ceil(u_img)*1.f,std::floor(v_img)*1.f); Eigen::Vector2f u01(std::floor(u_img)*1.f,std::ceil(v_img)*1.f); Eigen::Vector2f u11(std::ceil(u_img)*1.f,std::ceil(v_img)*1.f); float s = (u_img - u00.x()); float t = (v_img - u00.y()); Eigen::Vector3f u0 = lerp(s,getColor(u00.x()/width,u00.y()/height),getColor(u10.x()/width,u10.y()/height)); Eigen::Vector3f u1 = lerp(s,getColor(u01.x()/width,u01.y()/height),getColor(u11.x()/width,u11.y()/height)); Eigen::Vector3f color = lerp(t,u0,u1); return color; } Eigen::Vector3f lerp(float coefficient,Eigen::Vector3f a,Eigen::Vector3f b) { //return (coefficient * a + (1-coefficient) * b); return (a + coefficient*(b-a)); } For the code above, I have a few words to add: In opencv:Mat image;image.at&lt;&gt;(i,j) i–&gt;y j–&gt;xcolor order : BGRthe origin is at the upper-left corner Another one, Since have learned that one pixel can be seen as a little square. and the center of the pixel is (x + 0.5,y + 0.5); I tried this experiment using OpenCV, and found that : the result shows that they represent the same pixel. 12window.at&lt;cv::Vec3b&gt;(1,1)[1] = 255window.at&lt;cv::Vec3b&gt;(1,1.9)[1] = 255 References:[1]3D Math Primer for Graphics and Game Development 2nd Edition.[2]Fundamentals of Computer Graphics and 3rd Edition.[3]Unity+Shader入门精要[4]Unity3d Mannual[5]GAMES[6]scratchapixel","link":"/Graphics/Lighting-Shading-Texture/"},{"title":"C2-Matrix-Algebra","text":"Keywords: Inverse, LU Factorization, Homogeneous Coordinates, Perspective Projections, Rank Matrix Operation$$\\begin{aligned}&amp;AB \\neq BA\\\\&amp;AB = AC,it’s \\space not \\space true \\space B = C\\\\&amp;AB = 0, it’s \\space not \\space true \\space A = 0 \\space or \\space B = 0\\\\&amp;(A^T)^T = A\\\\&amp;(A+B)^T = A^T+B^T\\\\&amp;(AB)^T = B^TA^T\\\\&amp;A(BC) = (AB)C\\end{aligned}$$ The fastest way to obtain $AB$ on a computer depends on the way in whichthe computer stores matrices in its memory. The standard high-performancealgorithms, such as in LAPACK, calculate $AB$ by columns, as in our definitionof the product. (A version of LAPACK written in C++ calculates $AB$ by rows.) The definition of $AB$ lends itself well to parallel processing on a computer. Thecolumns of $B$ are assigned individually or in groups to different processors,which independently and hence simultaneously compute the correspondingcolumns of $AB$. The Inverse of MatrixAn $n \\times n$ matrix $A$ is said to be invertible if there is an $n \\times n$ matrix $C$ such that $$CA = I \\space and \\space AC = I$$ A matrix that is not invertible is sometimes called a singular matrix, and an invertible matrix is called a nonsingular matrix.一个不可逆的矩阵有时被称为奇异矩阵，一个可逆的矩阵被称为非奇异矩阵 $$\\begin{aligned}&amp; A = \\begin{bmatrix}a &amp; b \\\\ c &amp; d\\end{bmatrix}. \\spaceif \\space ad - bc \\neq 0, A \\space is\\space invertible\\\\&amp; A^{-1} = \\frac{1}{ad-bc}\\begin{bmatrix}d &amp; -b \\\\ -c &amp; a\\end{bmatrix}\\\\a&amp; d - bc = 0 , A\\space is \\space not \\space invertible\\\\&amp; det A = ad - bc(行列式)\\end{aligned}$$ If $A$ is an invertible $n \\times n$ matrix, then for each $\\vec{b}$ in $R^n$, the equation $A\\vec{x} = \\vec{b}$ has the unique solution $\\vec{x} = A^{-1}\\vec{b}$. $$(A^{-1})^{-1} = A\\\\(AB)^{-1} = B^{-1}A^{-1}\\\\(A^T)^{-1} = (A^{-1})^T\\\\$$ An $n \\times n$ matrix $A$ is invertible if and only if $A$ is row equivalent to $I_n$, and in this case, any sequence of elementary row operations that reduces A to $I_n$ also transforms $I_n$ into $A^{-1}$. For example: $$E_1 = \\begin{bmatrix}1 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 \\\\ -4 &amp; 0 &amp; 1\\end{bmatrix}\\\\transform \\space E_1 \\space to \\space I, get \\space I \\space to \\space E_1^{-1}:\\\\E_1^{-1} = \\begin{bmatrix}1 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 \\\\ 4 &amp; 0 &amp; 1\\end{bmatrix}$$ An algorithm for Finding $A^{-1}$Row reduce the augmented matrix $\\begin{bmatrix}A &amp; I\\end{bmatrix}$. If $A$ is row equivalent to $I$, then $\\begin{bmatrix}A &amp; I\\end{bmatrix}$ is row equivalent to $\\begin{bmatrix}I &amp; A^{-1}\\end{bmatrix}$. Other wise, A does not have an inverse. For example: Find the Inverse of the matrix A = $\\begin{bmatrix}0 &amp; 1 &amp; 2\\\\1 &amp; 0 &amp; 3\\\\4 &amp; -3 &amp; 8\\end{bmatrix}$, if it exists. $$\\begin{bmatrix}A &amp; I\\end{bmatrix} =\\begin{bmatrix}0 &amp; 1 &amp; 2 &amp; 1 &amp; 0 &amp; 0\\\\1 &amp; 0 &amp; 3 &amp; 0 &amp; 1 &amp; 0\\\\4 &amp; -3 &amp; 8 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\sim\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; \\frac{-9}{2} &amp; 7 &amp; \\frac{-3}{2}\\\\0 &amp; 1 &amp; 0 &amp; -2 &amp; 4 &amp; -1\\\\0 &amp; 0 &amp; 1 &amp; \\frac{3}{2} &amp; -2 &amp; \\frac{1}{2}\\end{bmatrix}\\longrightarrowA^{-1} = \\begin{bmatrix}\\frac{-9}{2} &amp; 7 &amp; \\frac{-3}{2}\\\\ -2 &amp; 4 &amp; -1\\\\ \\frac{3}{2} &amp; -2 &amp; \\frac{1}{2}\\end{bmatrix}$$ Characterizations of Inversible Matrix注意，这些性质的应用必须是n x n的矩阵 Let $A$ be a square $n \\times n$ matrix. Then the following statements are equivalent. That is, for a given $A$, the statements are either all true or all false.a. $A$ is an invertible matrix.b. $A$ is row equivalent to the $n \\times n$ identity matrix.c. $A$ has $n$ pivot positions.d. The equation $Ax = 0$ has only the trivial solution.e. The columns of $A$ form a linearly independent set.f. The linear transformation $x \\rightarrow Ax$ is one-to-one.g. The equation $Ax = b$ has at least one solution for each $b$ in $R^n$.h. The columns of $A$ span $R^n$.i. The linear transformation $x \\rightarrow Ax$ maps $R^n$ onto $R^n$.j. There is an $n \\times n$ matrix $C$ such that $CA = I$.k. There is an $n \\times n$ matrix $D$ such that $AD = I$.l. $A^T$ is an invertible matrix. Invertible Linear TransformationsLet $T :R^n\\rightarrow R^n$ be a linear transformation and let $A$ be the standard matrix for $T$. Then $T$ is invertible if and only if $A$ is an invertible matrix. In that case, the linear transformation $S$ given by $S(x) = A^{-1}x $ is the unique function satisfying equations (1) and (2) $$S(T(x)) = x, x \\in R^n\\tag{1}$$$$T(S(x)) = x, x \\in R^n\\tag{2}$$ 由于计算机的精度问题，you might occasionally encounter a “nearly singular” or illconditioned matrix—an invertible matrix, that can become singular if some of its entries are changed ever so slightly.In this case, row reduction may produce fewer than $n$ pivot positions, as a result of roundoff error.Also, roundoff error can sometimes make a singular matrix appear to be invertible. Partitioned Matrices$$A =\\left[ \\begin{array}{ccc|cc|c} 3 &amp; 0 &amp; -1 &amp; 5 &amp; 9 &amp; -2 \\\\ -5 &amp; 2 &amp; 4 &amp; 0 &amp; -3 &amp; 1 \\\\ \\hline -8 &amp; -6 &amp; 3 &amp; 1 &amp; 7 &amp; -4 \\end{array}\\right]$$can also be written as the $2 \\times 3$ partitioned (or block) matrix $$A = \\begin{bmatrix}A_{11} &amp; A_{12} &amp; A_{13} \\\\A_{21} &amp; A_{22} &amp; A_{23}\\end{bmatrix}$$ Multiplication of Partitioned Matrices$$A : m \\times n, B : n \\times p\\\\AB = \\begin{bmatrix}col_1(A) &amp; col_2(A) &amp; \\cdots &amp; col_n(A)\\end{bmatrix}\\begin{bmatrix}row_1(B) \\\\ row_1(B) \\\\ \\cdots \\\\ row_n(B)\\end{bmatrix}\\tag{1}$$ Inverse of Partitioned Matrices$$assume\\space A_{11}: p\\times p, A_{22}: q\\times q, A \\space invertible.A = \\begin{bmatrix}A_{11} &amp; A_{12}\\\\0 &amp; A_{22}\\end{bmatrix}\\tag{bolck upper triangular}$$ $$求逆过程如下：\\\\A_{11}B_{11} + A_{12}B_{21} = I_p\\tag{1}$$$$A_{11}B_{12} + A_{12}B_{22} = 0\\tag{2}$$$$A_{22}B_{21} = 0\\tag{3}$$$$A_{22}B_{22} = I_{q}\\tag{4}$$$$(1)(2)(3)(4)\\rightarrowA^{-1} = \\begin{bmatrix}A_{11} &amp; A_{12}\\\\0 &amp; A_{22}\\end{bmatrix} ^ {-1}=\\begin{bmatrix}A_{11}^{-1} &amp;-A_{11}^{-1}A_{12}A_{22}^{-1}\\\\0 &amp; A_{22}^{-1}\\end{bmatrix}$$ 分块矩阵提高计算机计算效率 When matrices are too large to fit in a computer’s high-speed memory, partitioning permits the computer to work with only two or three submatrices at a time. Matrix Factorizations 矩阵分解The LU Factorizationssume that $A$ is an $m \\times n$ matrix that can be row reduced to echelon form, without row interchanges. Then $A$ can be written in the form $A = LU$ , where $L$ is an $m \\times m$ lower triangular matrix with $1’s$ on the diagonal and $U$ is an $m \\times n$ echelon form of $A$. The matrix $L$ is invertible and is called a unit lower triangular matrix. 单位下三角矩阵$$A = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\\\ * &amp; 1 &amp; 0 &amp; 0\\\\ * &amp; * &amp; 1 &amp; 0\\\\ * &amp; * &amp; * &amp; 1\\end{bmatrix}\\begin{bmatrix}\\blacksquare &amp; * &amp; * &amp; * &amp; *\\\\0 &amp; \\blacksquare &amp; * &amp; * &amp; *\\\\0 &amp; 0 &amp; 0 &amp; \\blacksquare &amp; *\\\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\end{bmatrix}$$ 思考，这样分解有什么好处？ $$A\\vec{x} = \\vec{b}\\longrightarrowL(U\\vec{x}) = \\vec{b},\\\\let\\space \\vec{y} = U\\vec{x}\\Rightarrow\\\\\\begin{cases}L\\vec{y} = \\vec{b}\\\\U\\vec{x} = \\vec{y}\\tag{2}\\end{cases}$$ 分解后好求解，因为LU都是三角矩阵 For example： $$A =\\begin{bmatrix}3 &amp; -7 &amp; -2 &amp; 2\\\\-3 &amp; 5 &amp; 1 &amp; 0\\\\6 &amp; -4 &amp; 0 &amp; -5\\\\-9 &amp; 5 &amp; -5 &amp; 12\\end{bmatrix}=\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\-1 &amp; 1 &amp; 0 &amp; 0\\\\2 &amp; -5 &amp; 1 &amp; 0\\\\-3 &amp; 8 &amp; 3 &amp; 1\\end{bmatrix}\\begin{bmatrix}3 &amp; -7 &amp; -2 &amp; 2\\\\0 &amp; -2 &amp; -1 &amp; 2\\\\0 &amp; 0 &amp; -1 &amp; 1\\\\0 &amp; 0 &amp; 0 &amp; -1\\end{bmatrix}= LU,Solve A\\vec{x} = \\vec{b}, where\\spaceb =\\begin{bmatrix}-9 \\\\5 \\\\7 \\\\11\\end{bmatrix}$$Solution：$$\\begin{bmatrix}L &amp; \\vec{b}\\end{bmatrix} =\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0 &amp; -9\\\\-1 &amp; 1 &amp; 0 &amp; 0 &amp; 5\\\\2 &amp; -5 &amp; 1 &amp; 0 &amp; 7\\\\-3 &amp; 8 &amp; 3 &amp; 1 &amp; 11\\end{bmatrix}\\sim\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0 &amp; -9\\\\0 &amp; 1 &amp; 0 &amp; 0 &amp; -4\\\\0 &amp; 0 &amp; 1 &amp; 0 &amp; 5\\\\0 &amp; 0 &amp; 0 &amp; 1 &amp; 1\\end{bmatrix} =\\begin{bmatrix}I &amp; \\vec{y}\\end{bmatrix}\\\\\\begin{bmatrix}U &amp; \\vec{y}\\end{bmatrix} =\\begin{bmatrix}3 &amp; -7 &amp; -2 &amp; 2 &amp; -9\\\\0 &amp; -2 &amp; -1 &amp; 2 &amp; -4\\\\0 &amp; 0 &amp; -1 &amp; 1 &amp; 5\\\\0 &amp; 0 &amp; 0 &amp; -1 &amp; 1\\end{bmatrix}\\sim\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0 &amp; 3\\\\0 &amp; 1 &amp; 0 &amp; 0 &amp; 4\\\\0 &amp; 0 &amp; 1 &amp; 0 &amp; -6\\\\0 &amp; 0 &amp; 0 &amp; 1 &amp; -1\\end{bmatrix} =\\begin{bmatrix}I &amp; \\vec{x}\\end{bmatrix}$$ The LU Factorization AlgorithmSuppose $A$ can be reduced to an echelon form $U$ using only row replacements that add a multiple of one row to another row below it. In this case, there exist unit lower triangular elementary matrices $E_1,\\cdots,E_p$ such that: $$E_p\\cdots E_1A = U\\tag{3}$$Then$$A = (E_p\\cdots E_1)^{-1}U = LU$$where$$L = (E_p\\cdots E_1)^{-1}\\tag{4}$$ 从推导过程可以看出，$A$经历了哪些初等行变换，$L$也同时经历，最终$A$变成了$U$，$L$变成了$I$ It can be shown that products and inverses of unit lower triangular matrices are also unit lower triangular.Thus $L$ is unit lower triangular. For example:Find the $LU$ factorization of $A$.$$A =\\begin{bmatrix}2 &amp; 4 &amp; -1 &amp; 5 &amp; -2\\\\-4 &amp; -5 &amp; 3 &amp; -8 &amp; 1\\\\2 &amp; -5 &amp; -4 &amp; 1 &amp; 8\\\\-6 &amp; 0 &amp; 7 &amp; -3 &amp; 1\\end{bmatrix}$$ Solution：$$A = \\begin{bmatrix}\\bbox[border:2px solid red]2 &amp; 4 &amp; -1 &amp; 5 &amp; -2\\\\\\bbox[border:2px solid red]{-4} &amp; -5 &amp; 3 &amp; -8 &amp; 1\\\\\\bbox[border:2px solid red]2 &amp; -5 &amp; -4 &amp; 1 &amp; 8\\\\\\bbox[border:2px solid red]{-6} &amp; 0 &amp; 7 &amp; -3 &amp; 1\\end{bmatrix}\\sim\\begin{bmatrix}2 &amp; 4 &amp; -1 &amp; 5 &amp; -2\\\\0 &amp; \\bbox[border:2px solid red]3 &amp; 1 &amp; 2 &amp; -3\\\\0 &amp; \\bbox[border:2px solid red]{-9} &amp; -3 &amp; -4 &amp; 10\\\\0 &amp; \\bbox[border:2px solid red]{12} &amp; 4 &amp; 12 &amp; -5\\end{bmatrix}\\sim\\begin{bmatrix}2 &amp; 4 &amp; -1 &amp; 5 &amp; -2\\\\0 &amp; 3 &amp; 1 &amp; 2 &amp; -3\\\\0 &amp; 0 &amp; 0 &amp; \\bbox[border:2px solid red]2 &amp; 1\\\\0 &amp; 0 &amp; 0 &amp; \\bbox[border:2px solid red]4 &amp; 7\\end{bmatrix}\\sim\\begin{bmatrix}2 &amp; 4 &amp; -1 &amp; 5 &amp; -2\\\\0 &amp; 3 &amp; 1 &amp; 2 &amp; -3\\\\0 &amp; 0 &amp; 0 &amp; 2 &amp; 1\\\\0 &amp; 0 &amp; 0 &amp; 0 &amp;\\bbox[border:2px solid red]5\\end{bmatrix} = U$$$$\\begin{bmatrix}2\\\\-4\\\\2\\\\6\\end{bmatrix}\\begin{bmatrix}\\\\3\\\\-9\\\\12\\end{bmatrix}\\begin{bmatrix}\\\\\\\\2\\\\4\\end{bmatrix}\\begin{bmatrix}\\\\\\\\\\\\5\\end{bmatrix}\\\\\\div 2\\downarrow\\div 3\\downarrow\\div 2\\downarrow\\div 5\\downarrow\\\\\\begin{bmatrix}1 &amp; &amp; &amp; \\\\-2 &amp; 1 &amp; &amp; \\\\1 &amp; -3 &amp; 1 &amp; \\\\3 &amp; 4 &amp; 2 &amp; 1\\end{bmatrix} = L$$ The Leontief Input–Output Model(Omit)Applications to Computer GraphicsHomogeneous CoordinatesThe mathematics of computer graphics is intimately connected with matrix multiplication. Unfortunately, translating an object on a screen does not correspond directly to matrix multiplication because translation is not a linear transformation. The standard way to avoid this difficulty is to introduce what are called homogeneous coordinates. $$translation : (x,y)\\mapsto(x + h, y + k)\\\\homogeneous-translation: (x,y,1)\\mapsto(x + h, y + k, 1)\\\\matrix-multiplication:\\begin{bmatrix}1 &amp; 0 &amp; h\\\\0 &amp; 1 &amp; k\\\\0 &amp; 0 &amp; 1\\end{bmatrix}\\begin{bmatrix} x\\\\y\\\\1\\end{bmatrix}=\\begin{bmatrix}x + h\\\\y+k\\\\1\\end{bmatrix}$$ Any linear transformation on $R^2$ is represented with respect to homogeneous coordinates by a partitioned matrix of the form $\\begin{bmatrix}A &amp; 0 \\\\ 0 &amp; 1\\end{bmatrix}$, where $A$ is a $2 \\times 2$ matrix. Typical examples are: $$\\begin{bmatrix}\\cos\\psi &amp; -\\sin\\psi &amp; 0\\\\\\sin\\psi &amp; \\cos\\psi &amp; 0\\\\0 &amp; 0 &amp; 1\\end{bmatrix},\\begin{bmatrix}0 &amp; 1 &amp; 0\\\\1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1\\end{bmatrix},\\begin{bmatrix}s &amp; 0 &amp; 0\\\\0 &amp; t &amp; 0\\\\0 &amp; 0 &amp; 1\\end{bmatrix}$$ Homogeneous 3D Coordinates$(x,y,z,1)$ are homogeneous coordinates for the point $(x,y,z)$ in $R^3$. In general, $(X,Y,Z,H)$ are homogeneous coordinates for $(x,y,z)$ if $H \\neq 0$ $$x = \\frac{X}{H}, y = \\frac{Y}{H}, z = \\frac{Z}{H}$$ For example: Rotation about the y-axis through an angle of 30&deg; Solution: First, construct the $3\\times 3$ matrix for the rotation. The vector $\\vec{e_1}$ rotates down toward the negative $z-axis$, stopping at $(\\cos 30, 0, -\\sin 30) = (\\frac{\\sqrt{3}}{2}, 0 , -0.5)$. The vector $\\vec{e_2}$ on the y-axis does not move. The vector $\\vec{e_3}$ on the $z-axis$ rotates down toward the positive $x-axis$, stopping at $(\\sin 30, 0, \\cos 30) = (0.5, 0, \\frac{\\sqrt{3}}{2})$. So the rotation matrix is$$\\begin{bmatrix}\\frac{\\sqrt{3}}{2} &amp; 0 &amp; 0.5\\\\0 &amp; 1 &amp; 0\\\\-0.5 &amp; 0 &amp; \\frac{\\sqrt{3}}{2}\\end{bmatrix}$$ Perspective ProjectionsFor example: let $xy-plane$ represent the computer screen, and imagine that the eye of a viewer is along the positive $z-axis$, at point $(0,0,d)$.A perspective projection maps each point $(x,y,z)$ onto an image point $(x^{\\ast}, y^{\\ast}, 0)$. Solution: induce projection-matrix as follows： $$\\frac{x^{\\ast}}{d} = \\frac{x}{d-z}\\rightarrowx^{\\ast} = \\frac{dx}{d-z} = \\frac{x}{1-\\frac{z}{d}}$$$$Similarly\\rightarrow y^{\\ast} = \\frac{y}{1-\\frac{z}{d}}$$$$(x,y,z,1)\\xrightarrow{projection} (\\frac{x}{1-\\frac{z}{d}}, \\frac{y}{1-\\frac{z}{d}}, 0 ,1)\\sim(x,y,0,1-\\frac{z}{d})$$$$p\\begin{bmatrix}x\\\\y\\\\z\\\\1\\end{bmatrix}=\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; -1/d &amp; 1\\end{bmatrix}\\begin{bmatrix}x \\\\ y \\\\ z \\\\ 1 \\end{bmatrix}=\\begin{bmatrix}x \\\\ y \\\\ 0 \\\\ 1-\\frac{z}{d}\\end{bmatrix}$$ More about Rotation matrix &amp; Perspective projection &gt;&gt; SubSpace of $R^n$ A subspace of $R^n$ is any set $H$ in $R^n$ that has three properties: The Zero Vector is in $H$. For each $\\vec{u}$ and $\\vec{v}$ in $H$, the sum $\\vec{u} + \\vec{v}$ is in $H$. For each $\\vec{u}$ in $H$ and each scalar $c$, the vector $c\\vec{u}$ is in $H$. Column Space and Null Space of a MatrixThe column space of a matrix $A$ is the set $ColA$ of all linear combinations of the columns of $A$. if $A = \\begin{bmatrix}\\vec{a_1} &amp; \\cdots &amp; \\vec{a_n}\\end{bmatrix}$, with the columns in $R^m$, then $Col A$ is the same as $Span(\\vec{a_1} \\cdots \\vec{a_n})$. For example: Let A = $\\begin{bmatrix}1 &amp; -3 &amp; -4 \\\\-4 &amp; 6 &amp; -2 \\\\-3 &amp; 7 &amp; 6\\end{bmatrix}$ and b = $\\begin{bmatrix}3 \\\\3 \\\\-4\\end{bmatrix}$. Determine whether $\\vec{b}$ is in the column space of $A$. Solution: $$\\begin{bmatrix}1 &amp; -3 &amp; -4 &amp; 3\\\\-4 &amp; 6 &amp; -2 &amp; 3\\\\-3 &amp; 7 &amp; 6 &amp; -4\\end{bmatrix}\\sim\\begin{bmatrix}1 &amp; -3 &amp; -4 &amp; 3\\\\0 &amp; -6 &amp; -18 &amp; 15\\\\0 &amp; 0 &amp; 0 &amp; 0\\end{bmatrix}\\\\有解，意味着b是A列向量的线性组合\\thereforeb \\subseteq Col A$$ Basis for a Subspace A basis for a subspace $H$ of $R^n$ is a linearly independent set in $H$ that spans $H$. $$\\vec{e_1} = \\begin{bmatrix}1 \\\\ 0 \\\\ \\cdots \\\\ 0\\end{bmatrix},\\vec{e_2} = \\begin{bmatrix}0 \\\\ 1 \\\\ \\cdots \\\\ 0\\end{bmatrix},\\cdots,\\vec{e_n} = \\begin{bmatrix}0 \\\\ 0 \\\\ \\cdots \\\\ 1\\end{bmatrix}$$ the set {$\\vec{e_1}, \\cdots, \\vec{e_n}$} is called the standard basis for $R^n$. For example: Find a basis for the null space of the matrix. $$A = \\begin{bmatrix}-3 &amp; 6 &amp; -1 &amp; 1 &amp; -7\\\\1 &amp; -2 &amp; 2 &amp; 3 &amp; -1\\\\2 &amp; -4 &amp; 5 &amp; 8 &amp; -4\\end{bmatrix}$$ 找到矩阵零空间的一组基如下：$$\\begin{bmatrix}A &amp; \\vec{0}\\end{bmatrix}\\sim\\begin{bmatrix}1 &amp; -2 &amp; 0 &amp; -1 &amp; 3 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 2 &amp; -2 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\end{bmatrix},\\begin{bmatrix}x_1\\\\x_2\\\\x_3\\\\x_4\\\\x_5\\end{bmatrix}=\\begin{bmatrix}2x_2 + x_4 - 3x_5\\\\x_2\\\\-2x_4 + 2x_5\\\\x_4\\\\x_5\\end{bmatrix}=x_2\\begin{bmatrix}2\\\\1\\\\0\\\\0\\\\0\\\\\\end{bmatrix} + x4\\begin{bmatrix}1\\\\0\\\\-2\\\\1\\\\0\\end{bmatrix} + x_5\\begin{bmatrix}-3\\\\0\\\\2\\\\0\\\\1\\end{bmatrix}= x_2\\vec{u} + x_4\\vec{v} + x_5\\vec{w}\\\\{\\vec{u}, \\vec{v}, \\vec{w}} 是基向量$$ Dimension and RankMore About Dimension and Rank is in C4 &gt;&gt; Coordinate SystemsSuppose the set $\\beta = (\\vec{b_1},\\cdots\\cdots, \\vec{b_p})$ is a basis for a SubSpace $H$. For each $\\vec{x}$ in $H$, the coordinates of $\\vec{x}$ relative to the basis $\\beta$ are the weights $c_1, \\cdots, c_p$ such that $\\vec{x} = c_1\\vec{b_1} + \\cdots + c_p\\vec{b_p}$, and the vector in $R^p$$$[\\vec{x}]_\\beta =\\begin{bmatrix}c_1\\\\\\cdots\\\\c_p\\end{bmatrix}$$is called the coordinate vector of $\\vec{x}$(relative to $\\beta$) or the $\\beta-$ coordinate vector of $\\vec{x}$ The Dimension of a Subspace The rank of a matrix $A$, denoted by $rank A$, is the dimension of the column space of $A$ Determin the rank of the matrix$$A\\sim\\begin{bmatrix}2 &amp; 5 &amp; -3 &amp; -4 &amp; 8\\\\0 &amp; -3 &amp; 2 &amp; 5 &amp; -7\\\\0 &amp; 0 &amp; 0 &amp; 4 &amp; -6\\\\\\end{bmatrix}矩阵有3个pivot-columns，所以rankA = 3$$ If a matrix $A$ has $n$ columns, then $rank A + dim Nul A = n$. Rank and the Invertible Matrix Theorem Let $A$ be an $n \\times n$ matrix. Then the following statements are each equivalent to the statement that $A$ is an invertible matrix.m. The columns of $A$ form a basis of $R^n$:n. $Col A = R^n$o. $dim Col A = n$p. $rank A = n$q. $Nul A = {0}$r. $dim Nul A = 0$","link":"/Math/Linear-Algebra/C2-Matrix-Algebra/"},{"title":"Graphics Pipeline Overview","text":"Keywords: Rendering Pipeline, Deduce Projection Matrix, Rotation Matrix Just look at the middle part of Fig1,the working flow is followed. Step1.Setting up the sceneBefore we begin rendering,we must set several options that apply to the entire scene. For example,we need to set up the camera, to be more specifically,that means,pick a point of view in the scene from which to render it, and choose where on the screen to render it. We also need to select lighting and fog options, and prepare the depth buffer. If you have used Unity,then it is easy to understand, you put the camera in the proper place and set the lighting properties,also change the aspect ratio. Step2.Visibility determinationOnce we have a camera in place,we must then decide which objects in the scene are visible. In unity this means that you can tick the box on the Inspector panel to determine the object visible or not. Step3.Setting object-level rendering statesEach object may have its own rendering options. We must install these options into the rendering context before rendering any primitives associated with the object. The most basic property associated with an object is material that describes the surface propertis of the object. In unity,the material defines how the surface should be rendered,by including referencse to the texutres it uses,tiling information,color tints and so on. The avaliable options for a material depend on which shader the material is using. Step4.Geometry generation/deliveryThe geometry is actually submitted to the rendering API.Typically,the data is delivered in the form of triangles;either as individual triangles,or an indexed triangle mesh,triangle strip,or some other form. If you have heard about 3D Max or Maya,then you can get it.The artists create the model in the form of .obj file, we programmers load the model to the RAM, then we got the triangles data. You can achieve the obj_loader.h. Then you can get the triangles data like this: 123456789101112131415161718std::vector&lt;Triangle*&gt; TriangleList;objl::Loader Loader;bool loadout = Loader.LoadFile(obj_path);for(auto mesh:Loader.LoadedMeshes){ for(int i=0;i&lt;mesh.Vertices.size();i+=3) { Triangle* t = new Triangle(); for(int j=0;j&lt;3;j++) { t-&gt;setVertex(j,Vector4f(mesh.Vertices[i+j].Position.X,mesh.Vertices[i+j].Position.Y,mesh.Vertices[i+j].Position.Z,1.0)); t-&gt;setNormal(j,Vector3f(mesh.Vertices[i+j].Normal.X,mesh.Vertices[i+j].Normal.Y,mesh.Vertices[i+j].Normal.Z)); t-&gt;setTexCoord(j,Vector2f(mesh.Vertices[i+j].TextureCoordinate.X, mesh.Vertices[i+j].TextureCoordinate.Y)); } TriangleList.push_back(t); }}draw(TriangleList); In unity, this is done by the powerful engine. Step5.Vertex-level operationsOnce we have the geometry in some triangulated format,a number of various operations are performed at the vertex level. The most important operation is the transformation of vertex positions from modeling space into camera space/clip space. In unity, this operation is performed by a user-supplied microprogram called vertex shader. Like this: 1234567891011121314151617181920212223struct a2v{ float4 vertex : POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; float4 texcoord : TEXCOORD0;};struct v2f{ float4 pos : SV_POSITION; float4 uv : TEXCOORD0; float3 lightDir: TEXCOORD1; float3 viewDir : TEXCOORD2;};v2f vert(a2v v){ v2f o; //transform the vertex positions from modeling space into clip space o.pos = UnityObjectToClipPos(v.vertex); //... return o;} Though Unity has encapsulated the transformation function for us,there exists lots things to write.  We all know that the models that artists give us is in the model space,then how to transform them to the world space/camera space(view space)/clip space/screen space? How to deduce the matrixs(mvp)? What is the coordinates difference among OpenGL,DirectX and Unity? I will describe those in the Appendix :) Actually,the details have confused me for a long time,if you have the same feeling,don’t worry.Just go ahead. After we transformed the triangles to the camera space, any portion of a triangle outside the view frustum is removed, by the process known as clipping. Here the mvp matrix have ended. Once we have a clipped polygon in 3D clip space, we then project the vertices of that polygon,mapping them to 2D screen-space coordinates of the output window, here the viewport matrix is used. Step6.RasterizationOnce we have a clipped polygon in screen space,it is rasterized. Rasterization refers to the process of selecting which pixels on the screen should be drawn for a particular triangle; interpolating texture coordinates, colors, and lighting values that were computed at the vetex level across the face for each pixel; and passing these down to the next stage for pixel(fragment) shading. The pseudo-code is as follows: 123456789101112131415161718192021222324252627...got the TriangleListfor (const auto&amp; t:TriangleList){ //...mvp //...viewport rasterize(t);}rasterize(){ //...get the triangle bounding box for(x = x_min; x &lt; x_max+1; x++&gt; { for(y = y_min; y &lt; y_max+1; y++) { //...if the pixel(x,y) is the triangle t //...interpolate the depth buffer/color/normal/texcoords/shadingcoords. if(depth_buffer &lt; z_buffer[]) means visible { //...compute the color(texture/lighting...)(pixel shading) setpixel(x,y,color); } } }} Attention: in the code above, why we need the shadingcoords. That’s because, variable x,y is in the screen space, but the shading process should be done in the world space/view space/clip space. In unity, rasterization is mostly done by the powerful engine, but we can control the process of viewport to adjust the game to different resolution platforms and control the shader part to get more amazing effects. Step7.Pixel(fragment) shadingWe compute a color for the pixel,a process known as shading. The innocuous phrase “compute a color” is the heart of computer graphics! In unity, we write the fragment shader to compute the pixel colors under different lighting models. code-snippet as follows,from [3]. 1234567891011121314151617181920212223fixed4 frag(v2f i) : SV_Target { fixed3 tangentLightDir = normalize(i.lightDir); fixed3 tangentViewDir = normalize(i.viewDir); // Get the texel in the normal map fixed4 packedNormal = tex2D(_BumpMap, i.uv.zw); fixed3 tangentNormal; // If the texture is not marked as \"Normal map\" //tangentNormal.xy = (packedNormal.xy * 2 - 1) * _BumpScale; //tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy))); // Or mark the texture as \"Normal map\", and use the built-in funciton tangentNormal = UnpackNormal(packedNormal); tangentNormal.xy *= _BumpScale; tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy))); fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo; fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(tangentNormal, tangentLightDir)); fixed3 halfDir = normalize(tangentLightDir + tangentViewDir); fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(tangentNormal, halfDir)), _Gloss); return fixed4(ambient + diffuse + specular, 1.0);} From the code we can see that the fragment shader computes the ambient,diffuse,specular,the MainTex &amp; BumpMap texture controls the coefficients value of lighting model formulas. The lighting model is much more than you see. There are many physical formulas. But they are not hard to understand. You can get the details from the reference books[1][2][3]. Step8.Blending and OutputFinally! At the bottom of the render pipeline, we have produced a color,opacity, and depth value. The depth value is tested against the depth buffer for per-pixel visibility determination to ensure that an object farther away from the camera doesn’t obscure one closer to the camera. Pixels with an opacity that is too low are rejected, and the output color is then combined with the previous color in the frame buffer in a process known as alpha blending. SUMMARYOK! Now the 8 steps have all been listed. You may want to overview the rough processes. The pseudocode summarizes the simplified rendering pipeline outlined above, from[1]. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// First , figure how to view the scenesetupTheCamera ( ) ;// Clear the zbufferclearZBuffer ( ) ;// Setup environmental lighting and fogsetGlobalLightingAndFog ( ) ;// get a l i s t of objects that are potentially visiblepotentiallyVisibleObjectList = highLevelVisibilityDetermination ( scene ) ;// Render everything we found to be potentially visiblefor ( all objects in potentiallyVisibleObjectList ) { // Perform lower−level VSD using bounding volume test i f (! object . isBoundingVolumeVisible ( ) ) continue ; // Fetch or procedurally generate the geometry triMesh = object . getGeometry ( ) // Clip and render the faces for ( each triangle in the geometry ) { // Transform the vertices to clip space , and perform // vertex−level calculations (run the vertex shader ) clipSpaceTriangle = transformAndLighting ( triangle ) ; // Clip the triangle to the view volume clippedTriangle = clipToViewVolume ( clipSpaceTriangle ) ; i f ( clippedTriangle . isEmpty ( ) ) continue ; // Project the triangle onto screen space screenSpaceTriangle = clippedTriangle . projectToScreenSpace ( ) ; // Is the triangle backfacing ? i f ( screenSpaceTriangle . isBackFacing ( ) ) continue ; // Rasterize the triangle for ( each pixel in the triangle ) { // Scissor the pixel here ( i f triangle was // not completely clipped to the frustum ) i f ( pixel is off−screen ) continue ; // Interpolate color , zbuffer value , // and texture mapping coords // The pixel shader takes interpolated values // and computes a color and alpha value color = shadePixel ( ) ; // Perform zbuffering i f (! zbufferTest ( ) ) continue ; // Alpha test to ignore pixels that are ”too // transparent” i f (! alphaTest ( ) ) continue ; // Write to the frame buffer and zbuffer writePixel ( color , interpolatedZ ) ; // Move on to the next pixel in this triangle } // Move on to the next triangle in this object }// Move on to the next potentially visible object} AppendixSince we referred to Coordinates Transformation in Step5. I guess you may not very clear about the internal matrixs and the workflow. Come on baby! Time to overcome the difficulties! Model,World,Camera Space,Clip SpaceThe geometry of an object is initially described in object space,which is a coordinate space local to the object. The information described usually consisits of vertex positions and surface normals. Object space = Model space = Local spaceForm the model space,the vertices are transformed into world space. The transformation from modeling space to world space is often called model transform. Typically,lighting for the scene is specified in world space,but it doesn’t matter what coordinate space is used to perform the lighting calculations provided that the geometry and the lights can be expressed in the same space. So it is not weird that you see lighting calculations in the world space,or view space,or tangent space,or clip space in unity shader file. From world space,vertices are transformed into camera sapce. Camera space is a 3D coordinate space in which the origin is at the center of projection,one is axis parallel to the direction the camera is facing(perpendicullar to the projection plane),one axis is the intersection of the top and bottom clip planes,and the other axis is the intersection of the left and right clip planes. Camera space = View space = Eye spaceHere we should be alert to the difference between left-handed world and right-handed world,as shown in Fig2.In the left-handed world,the most common convention is to point +z in the direction that the camera is facing,with +x and +y pointing “right” and “up”.This is fairly intuitive,as shown in Fig3.The typical right-handed convention is to have -z point in the direction that the camera is facing. From camera space,vertices are transformed once again into clip space. The matrix that transforms vertices from camera space into clip space is called the clip matrix. clip space = canonical view volume space clip matrix = projection matrixMore Learning on Transformation and Matrix &gt;&gt; References:[1]3D Math Primer for Graphics and Game Development 2nd Edition.[2]Fundamentals of Computer Graphics and 3rd Edition.[3]Unity+Shader入门精要[4]Unity3d Mannual[5]GAMES","link":"/Graphics/Graphicspipeline/"},{"title":"OpenPose-Practice","text":"This article is for NOBODY, just for me to record.I tried to download OpenPose from github and run the Demo on my laptop. Since my graphics card is medium-level AMD,and my cpu is i7. So I use the cpu-only model. The code path is on the master branch. I use v1.5.1,so I can compile the source code by myself, that means I can change the code and make the dll files match my system best. I have tried the file that they compiled , and It didn’t work on my laptop. something that I want the say ,that is the command: 1bin\\OpenPoseDemo.exe --video examples\\media\\video.avi I got the idea on this issue and I have get the lesson: read files in the DOC folder first. you can see the project structure: so after downloaded the source code also the models,and do everything followed toturials(include cmake process)I compiled it by my vs2017 enterprise:When use cmake,the build folder can be created internally.Note: the red rectangles means that they are created by my self. Be careful about the files in them. Here’s some important tutorials I must show: Just read them… The result about the video is :the video process is really really slow, I take it becuase the author said the highly recommand 6 cores cpu ,and my cpu is 2 cores. I also tried the camera mode , but it’s black for one minute,two minuts,three minutes… I really didn’t think the program would have started if the headlight on my laptop camera hadn’t been on. It was too slow ,tooooooo slow… If the hardwares are good enough, the result canbe realtime I think. 1bin\\OpenPoseDemo.exe So I will try the NVIDIA+CUDA+CUDNN experiment next time I got the chance to have high-quality hardwares. I also tested the Openpose-unity-Plugin. The project structure is : This plugin needs windows7\\8\\9, and my system is Windows10,also the Unity version needs to be 2018.3,2018.4,and my Unity version is 2018.3.0f.But it’s not working…the error is:I changed the .bat file,but nothing happened, even the openposedemo.exe cannot use the cpu mode.So I don’t think their gpu-&gt;cpu conversion can be working…The issue is. Maybe not only testBinary.bat should be changed,the getModels.bat and getPlugins.bat should be changed too.and I wonder whether the models trained on gpu and cpu have any differences or not.But so far as I know, the models’ link are the same. So decided make part of the plugin myself,though I choosed the BUILD_UNITY_SUPPORT ,the result has no difference than before.Here’ the difference between their files and mine.I copyed the files on the left to the right, and the error is :You need to compile OpenPose with CUDA support in order to use GPU resize. My GOD!!! SO this means that the Unity-plugin still cannot use cpu mode. I take another try, download the release version and copy the plugin folder from older project to it. The error is new: So I ran the bat file to get the default plugin folder,also wrong,beacause it still want to find cuda…","link":"/DeepLearning/OpenPose-Practice/"},{"title":"First-Met-With-RayTracing","text":"Hey guys,speaking of RayTracing,I have to tell u that I’m really confused at the first time–What the hell is RayTracing?! Well u know I’m not the kind of person who is addicted to games, all I know about Graphics begins with the course UnityGame in my first year of Graduate,before that I am the one who doesn’t even know what pixel is! So not to mention those much more advanced technologies such as RayTracing! I assume readers are the same with me! You just learned the really really basic graphics—！ coordinates transformation,！ uv mapping,！ something about graphicspipeline,！ unity games,(ok I admit that I’m a little irritable at present, cuz a bug cannot be fixed for a few days)suddenly a voice told you time to learn RayTracing, and it seems a mess with the existing knowledges in your head. Don’t worry, learn with me. This article is going to be very very long, it’s about RayTracing,Acceleration,BRDF,PathTracing,Calculus,Global illumination,Unity,VScode etc, there will be lots pics and formulas. If you are patient enough to read through it, I promise you can learn something, but before this article, please scan the two articles:Lighting-Shading-Texture,Graphicspipeline,cuz we have lots things to link up. RAY-TRACINGWhy RayTracing?AccelerationRADIOMETRYRadiometry is closely related to calculus. If you know nothing about Calculus, please go to learn it and later come back, at least have the conception in your head. Though I’ll begin with mathematics first. Spherical CoordinatesWe all know Cartesian coordinates, cuz we define the points and vectors in Cartesian coordinate system since high school. Actually,we can also use Spherical coordinates to define them. In spherical coordinate system,the position of a point or direction and length of a vector are defined by two angles(denoted $\\theta$ and $\\phi$) and a radial distance($r$). The angle $\\theta$ is called polar angle and is measured from the fixed zenith direction.The zenith direction in relation to which this polar angle will be measured is the y-axis. To go from spherical coordinates to cartesian coordinates,we can use the following equation: $$x = r sin(\\theta)cos(\\phi)$$$$y = r cos(\\theta)$$$$z = r sin(\\theta)sin(\\phi)\\tag{spherical2cartesian}$$ Also to go from cartesian coordinates to spherical coordinates,we can use the following equation: $$r = \\sqrt{x^2+y^2+z^2}$$$$\\theta = cos^{-1}(\\frac{y}{r})$$$$\\phi = tan^{-1}(\\frac{z}{x})\\tag{catesian2spherical}$$ Differential and Integral CalculusCalculus includes differential and integral. Since this is really basic math,I’ll just make a rough review. The first fundamental theorem of calculus: $$F = \\int f(x)dx\\tag{1}$$ The second fundamental theorem of calculus: $$\\int_{a}^{b}f(x)dx = F(b)-F(a)\\tag{2}$$ The above is about functions defined in one dimension($f(x)$ takes one variable only, $x$). How about the functions in two dimension,even three dimension? So the integral of the function in the above pic is :$$\\int_{ax}^{bx}\\int_{ay}^{by}f(x,y)dxdy\\tag{2d integral}$$ So the integral of the function in the above pic is :$$\\rho = \\int_{ax}^{bx}\\int_{ay}^{by}\\int_{az}^{bz}f(x,y,z)dxdydz\\tag{3d integral}$$$\\rho$ means the density of the volume. RadiometryPreviously on the RayTracing part, the Whitted style ray tracing cannot give us correct results. That’s because the shading part only used empirical model. Blinn-phong Model cannot give us correct resutls, it’s only an empirical model, not based on physics, there’s lots materials blinn-phong cannot present. We want to simulate much more materials in our real life on computer, which means we need the PBS(physically based shading),and Radiometry is the basic concept of PBS. To begin with radiometry, we have new terms to remember: Radiant flux intensity irradiance radiance Radiant Energy and Flux(Power)We all know what Energy and Power mean in physics. They are almost the same in CG. Radiant energy is the energy of electromagnetic radiation. It is measured in units of joules, and denoted by the symbol: $$Q[J = Joule]$$ Radiant flux(power) is the energy emitted,reflected,transmitted or received, per unit time. $$\\Phi = \\frac{dQ}{dt} [W = Watt][lm = lumen]\\tag{flux}$$ Before go to intensity,irradiance,radiance,here’s a pic. Radiant IntensityRadiant intensity is the power per unit solid angle emitted by a point light source. $$I(\\omega) = \\frac{d\\Phi}{d\\omega} [\\frac{W}{sr}][\\frac{lm}{sr}=cd=candela]\\tag{intensity}$$ Angle:ration of subtended arc length on circle to radius $\\theta = \\frac{l}{r}$ Circle has $2\\pi$ radians Solid angle:ration of subtended area on sphere to radius squared $\\Omega = \\frac{A}{r^2}$ Sphere has $4\\pi$ steradians $$dA = (rd\\theta)(rsin\\theta d\\phi) = r^2 sin\\theta d\\theta d\\phi$$$$d\\omega = \\frac{dA}{r^2} = sin\\theta d\\theta d\\phi \\tag{solid angles}$$ IrradianceIrradiance is the power per(perpendicular/projected)unit area incident on a surface point. $$E(x) = \\frac{d\\Phi(x)}{dA} [\\frac{W}{m^2}][\\frac{lm}{m^2} = lux]\\tag{irradiance}$$ Do you still rememeber that in the Lighting-Shading-Texture article, we mentioned the empirical model Blinn phong model, and there’s diffuse component, when we calculate the diffuse component, we just assume the point’s worldposition,the point’s worldnormal etc. Actually,we assume this point is not really a point but a very small surface which we call differential area, denoted as $dA$.Now,what we actually consider as well is the amount of light falling on the surface of this very small area around P.Light that falls at P is not reduced to a single light ray since we are not interested in singular point but the small region $dA$ around that point. Light that falls on this region is contained within a small volume perpendicular to P. In the empirical model, the diffuse component is calculated like this:$$c_{diff} = c_{light} \\cdot m_{diff} \\cdot max(0,n \\cdot l)\\tag{blinn-phong-diffuse}$$as before, n is the surface normal and l is a unit vector that points towards the light source. The factor $m_{diff}$ is the material’s diffuse color, which is the value that most people think of when they think of the “color” of an object. The diffuse material color often comes from a texture map. The diffuse color of the light source is $c_{light}$. 1fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * max(0, dot(worldNormal, worldLightDir)); The diffuse component obeys Lambert’s Cosine Law,here the Irradiance also obeys Lambert’s Cosine Law: RadianceRadiance(luminance) is the power emitted,reflected, transmitted or received by a surface, per unit solid angle, per projected unit area.Radiance is the fundamental field quantity that describes the distribution of light in an environment Radiance is the quantity associated with a ray Rendering is all about computing radiance $$L(p,\\omega) = \\frac{d^2\\Phi(p,\\omega)}{d\\omega dAcos\\theta} [\\frac{W}{sr m^2}][\\frac{cd}{m^2} = \\frac{lm}{sr m^2} = nit]\\tag{radiance}$$ Incident Radiance Incident radiance is the irradiance per unit solid angle arriving at the surface Exiting Radiance Exiting surface radiance is the intensity per unit projected area leaving the surface. Those concepts are really hard to remember, but don’t feel frustrated. Keep going. Read more. If you cannot recall the concepts, turn back, read again. BRDFFinally BRDF. Actualy the Radiometry step is for BRDF.As mentioned above what Phong essentially used to simulate the appearance of shiny materials is a function. This function (which includes a specular and a diffuse compute). This function contains a certain number of parameters such as n that can be tweaked to change the appearance of the material, but more importantly, it actually depends on two variables, the incident light direction (which is used to compute both the diffuse and specular component) and the view direction (which is used to compute the specular component only). We could essential write this function as: $$f_R(\\omega_o,\\omega_i)$$Where $\\omega_o$ and $\\omega_i$ are the angle between the surface normal (N) and the view direction (V) and the surface normal and the light direction (I) respectively.The subscript o stands for outgoing. In computer graphics, this function is given the fancy name of Bidirectional Reflectance Distribution Function or in short BRDF. A BRDF is nothing else than a function that returns the amount of light reflected in the view direction for a given incident light direction: $$BRDF(\\omega_o,\\omega_i)$$ In the following pic,BRDF represents how much light is reflected into each outgoing direction $\\omega_r$ from each incoming direction: $$f_r(\\omega_i \\rightarrow \\omega_r) = \\frac{dL_r(\\omega_r)}{dE_i(\\omega_i)} = \\frac{dL_r(\\omega_r)}{L_i(\\omega_i)cos\\theta_i d\\omega_i}\\tag{BRDF}$$ One thing that I want to mention, why camera can see the objects? It’s because when one light beam hits the surface, it will reflect in all directions among the half hemisphere, but only the reflected light enter the viewer’s eye make sense. So we need to calculate the output reflected light. So here come’s The Reflection Equation. $$L_r(p,\\omega_r) = \\int_{H^2}f_r(p,\\omega_i \\rightarrow \\omega_r)L_i(p,\\omega_i)cos\\theta_i d\\omega_i\\tag{The-Reflection-Equation}$$ Please make sure you understand the meaning of each symbol in the above formulas. Here come’s The Rendering Equation. $$L_o(p,\\omega_o) = L_e(p,\\omega_o) + \\int_{\\Omega^+}L_i(p,\\omega_i)f_r(p,\\omega_i,\\omega_o)(n\\cdot\\omega_i)d\\omega_i\\tag{The-Rendering-Equation}$$ $L_e(p,\\omega_o)$ means the object’point p emit the emissive light to the $\\omega_o$ direction(remeber the $\\omega_o$ direction should be the view direction), and $\\int_{\\Omega^+}L_i(p,\\omega_i)f_r(p,\\omega_i,\\omega_o)(n\\cdot\\omega_i)d\\omega_i$ means the reflected light from $L_i(p,\\omega_i)$. Summary global illuminationPATH TRACINGAppendixMonte Carlo MethodsBefore we start, one question, do u have the background in Probability and Statistics Theory? If the answer is no, please go to learn something and later come back. What is Monte Carlo?Assume that we want to know the average height of all adults in one city, the most common method is to sample some adults and calculate the average height of them to approximate the true result. Here’s the formula: $$Approximation(Average(X)) = \\frac{1}{N}\\sum_{n=1}^{N}x_{n}$$ We generally denote random variables with upper case letters,the height of a population would be called a random variable,so the letter X is used.The formula can be read as,the approximation of the average value of the random variable X(the height of the adult population of the given country),is equal to sum of the height of N adults randomly chosen from that population(the samples),divided by the number N(the sample size). This in essence, is called a Monte Carlo approximation. In statistics,the average of the random variable X is called an expectation and is written E(X). So To summarize, Monte Carlo approximation (which is one of the MC methods) is a technique to approximate the expectation of random variables, using samples. Monte Carlo raytracing References: [1]GAMES [2]scratchapixel [3]3D Math Primer for Graphics and Game Development 2nd Edition. [4]Fundamentals of Computer Graphics and 3rd Edition. [5]Unity+Shader入门精要 [6]Unity3d Mannual [7]VSCode Document [8]基于物理着色：BRDF [9]如何正确理解 BRDF","link":"/Graphics/Rendering/First-Met-With-RayTracing/"},{"title":"address-opereator","text":"This is for the readers who have basic c++ background. Those days I have noticed that there’s char ‘&amp;’ in front of function. So decided to record it. I suggest an online c++ compiler : (You can test your simple programs on it.) 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;int&amp; fun(int &amp;a){ cout &lt;&lt; \"aa \" &lt;&lt; &amp;a &lt;&lt;endl; return a;}int main(){ int b; cout &lt;&lt; \"b: \" &lt;&lt; &amp;b &lt;&lt;endl; b = 4; cout &lt;&lt; \"fun: \"&lt;&lt; &amp;fun(b) &lt;&lt; endl; int a; cout &lt;&lt; \"a: \" &lt;&lt; &amp;a &lt;&lt; endl; a = fun(b); cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &amp;a &lt;&lt; endl;} The result is : 1234567b: 0x7ffe5ec356b8fun: aa 0x7ffe5ec356b80x7ffe5ec356b8a: 0x7ffe5ec356bcaa 0x7ffe5ec356b840x7ffe5ec356bc To be honest, &amp; and * are too hard in c++.","link":"/C/address-opereator/"},{"title":"C4-Vector-Spaces","text":"Keywords: SubSpaces, NullSpace and ColSpace, Coordinates Mapping, Dimension, Rank, Difference Equation, Markov Chains Vector Spaces and SubSpaces A subspace of a vector space $V$ is a subset $H$ of $V$ that has three properties:a. The zero vector of $V$ is in $H$.b. $H$ is closed under vector addition. That is, for each $\\vec{u}$ and $\\vec{v}$ in $H$, the sum $\\vec{u} + \\vec{v}$ is in $H$.c. $H$ is closed under multiplication by scalars. That is, for each $\\vec{u}$ in $H$ and each scalar $c$, the vector $c\\vec{u}$ is in $H$. if $\\vec{v_1} \\cdots \\vec{v_p}$ are in a vector space $V$, then Span{$\\vec{v_1} \\cdots \\vec{v_p}$} is a subspace of $V$. For Example: Let $H$ be the set of all vectors of the form $(a - 3b, b - a, a, b)$, where $a$ and $b$ are arbitrary scalars. That is, let $H = \\lbrace a - 3b, b - a, a, b \\rbrace$, $a$ and $b$ in $R$. Show that $H$ is a subspace of $R^4$. Proof： Write the vectors in $H$ as column vectors. Then the arbitrary vector in $H$ has the form $$\\begin{bmatrix}a-3b \\\\ b-a \\\\ a \\\\ b\\end{bmatrix}=a\\begin{bmatrix}1 \\\\ -1 \\\\ 1 \\\\ 0\\end{bmatrix} +b\\begin{bmatrix}-3 \\\\ 1 \\\\ 0 \\\\ 1\\end{bmatrix}$$ This calculation shows that H = Span{$\\vec{v_1}, \\vec{v_2}$}, where $\\vec{v_1}$ and $\\vec{v_2}$ are the vectors indicated above. Thus $H$ is a subspace of $R^4$. Null Spaces, Column Spaces, And Linear TransformationsThe Null Space of a MatrixThe null space of an $m \\times n$ matrix $A$, written as $Nul A$, is the set of all solutions of the homogeneous equation $A\\vec{x} = \\vec{0}$. In set notation,$$Nul A = \\lbrace\\vec{x} : \\vec{x} \\space in\\space R^n and A\\vec{x} = 0\\rbrace$$ The null space of an $m \\times n$ matrix $A$ is a subspace of $R^n$. An Explicit Description of Nul AFor Example: Find a spanning set for the null space of the matrix$$A =\\begin{bmatrix}-3 &amp; 6 &amp; -1 &amp; 1 &amp; -7\\\\1 &amp; -2 &amp; 2 &amp; 3 &amp; -1\\\\2 &amp; -4 &amp; 5 &amp; 8 &amp; -4\\end{bmatrix}$$ Solution: $$\\begin{bmatrix}-3 &amp; 6 &amp; -1 &amp; 1 &amp; -7 &amp; 0\\\\1 &amp; -2 &amp; 2 &amp; 3 &amp; -1 &amp; 0\\\\2 &amp; -4 &amp; 5 &amp; 8 &amp; -4 &amp; 0\\end{bmatrix}\\sim\\begin{bmatrix}1 &amp; -2 &amp; 0 &amp; -1 &amp; 3 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 2 &amp; -2 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\end{bmatrix}\\begin{bmatrix}x_1 \\\\ x_2 \\\\ x_3 \\\\x_4 \\\\x_5\\end{bmatrix} =\\begin{bmatrix}2x_2+x_4-3x_5 \\\\ x_2 \\\\ -2x_4+2x_5 \\\\x_4 \\\\x_5\\end{bmatrix} =x_2\\begin{bmatrix}2 \\\\ 1 \\\\ 0 \\\\ 0 \\\\ 0\\end{bmatrix} +x_4\\begin{bmatrix}1 \\\\ 0 \\\\ -2 \\\\ 1 \\\\ 0\\end{bmatrix} +x_5\\begin{bmatrix}-3 \\\\ 0 \\\\ 2 \\\\ 0 \\\\ 1\\end{bmatrix}= x_2\\vec{u} + x_4\\vec{v} + x_5\\vec{w}$$ Every linear combination of $\\vec{u},\\vec{v},\\vec{w}$ is an element of $Nul A$ and vice versa. Thus $\\lbrace\\vec{u},\\vec{v},\\vec{w}\\rbrace$ is a spanning set for $Nul A$. The Column Space of a MatrixThe column space of an $m \\times n$ matrix A, written as $Col A$, is the set of all linear combinations of the columns of A. If $A = \\left[\\vec{a_1}, \\cdots, \\vec{a_n}\\right]$, then$$ColA = Span\\lbrace\\vec{a_1}, \\cdots, \\vec{a_n}\\rbrace$$ The column space of an $m \\times n$ matrix A is a subspace of $R^m$. Note that a typical vector in $Col A$ can be written as $A\\vec{x}$ for some $\\vec{x}$ because the notation $A\\vec{x}$ stands for a linear combination of the columns of $A$. That is, $$Col A = \\lbrace \\vec{b} : \\vec{b} = A \\vec{x} for \\space some\\space x \\space in \\space R^n\\rbrace$$ The Contrast Between Nul A and Col AContrast Between $NulA$ and $ColA$ for an $m \\times n$ Matrix $A$ $NulA$ $ColA$ 1. $NulA$ is a subspace of $R^n$. 1.$ColA$ is a subspace of $R^m$. 2.$NulA$ is implicitly defined; that is, you are given only a condition $A\\vec{x}=\\vec{0}$that vectors in $NulA$ must satisfy. 2.$ColA$ is explicitly defined; that is, you are told how to build vectors in $ColA$. 3. it takes time to find vectors in $NulA$. Row operations on $\\begin{bmatrix}A &amp; \\vec{0} \\end{bmatrix}$ are required. 3. It is easy to find vectors in $ColA$. The columns of $A$ are displayed; others are formed from them 4. There is no obvious relation between $NulA$ and the entries in $A$. 4. There is an obvious relation between $ColA$ and the entries in $A$, since each column of $A$ is in $ColA$. 5. A typical vector $\\vec{v}$ in $NulA$ has the property that $A\\vec{v} = \\vec{0}$. 5. A typical vector $\\vec{v}$ in$ColA$has the property that the equation $A\\vec{x} = \\vec{v}$ is consistent. 6. Given a specific vector $\\vec{v}$, it is easy to tell if $\\vec{v}$ is in $NulA$. Just compute $A\\vec{v}$. 6. Given a specific vector $\\vec{v}$, it may take time to tell if $\\vec{v}$ is in $ColA$. Row operations on are required. 7. $NulA = \\lbrace\\vec{0}\\rbrace$ if and only if the equation $A\\vec{x} = \\vec{0}$ has only the trivial solution. 7. $ColA = R^m$ if and only if the equation $A\\vec{x} = \\vec{b}$ has a solution for every $\\vec{b}$ in $R^m$. 8. $NulA = \\lbrace\\vec{0}\\rbrace$ if and only if the linear transformation $\\vec{x} \\mapsto A\\vec{x}$ is one-to-one. 8.$ColA = R^m$ if and only if the linear transformation $\\vec{x} \\mapsto A\\vec{x}$ maps $R^n$ onto $R^m$. Linearly Independent Sets; Bases An indexed set $\\lbrace \\vec{v_1}, \\cdots, \\vec{v_p} \\rbrace$ of two or more vectors, with $\\vec{v_1} \\neq \\vec{0}$, is linearly depentdent if and only if some $\\vec{v_j}$(with $j &gt; 1$) is a linear combination if the preceding vectors $\\vec{v_1}, \\cdots, \\vec{v_{j-1}}$. Let $H$ be a subspace of a vector space $V$. An indexed set of vectors $\\beta = \\lbrace \\vec{b_1}, \\cdots, \\vec{b_p}\\rbrace$ in $V$ is a basis for $H$ if(i) $\\beta$ is a linearly independent set, and(ii) the subspace spanned by $\\beta$ coincides with $H$; that is $$H = Span \\lbrace \\vec{b_1}, \\cdots, \\vec{b_p} \\rbrace$$ For Example: Let $S = \\lbrace 1, t, t^2, \\cdots, t^n \\rbrace$. Verify that $S$ is a basis for $P_n$. This basis is called the standard basis for $P_n$. Solution: Certainly $S$ spans $P_n$. To show that S is linearly independent, suppose that $c_0, \\cdots, c_n$ satisfy $$c_0 \\cdot 1 + c_1 \\cdot t + c_2 \\cdot t^2 + \\cdots + c_n \\cdot t^n = \\vec{0_t}\\tag{2}$$ This equality means that the polynomial on the left has the same values as the zero polynomial on the right. A fundamental theorem in algebra says that the only polynomial in $P_n$ with more than $n$ zeros is the zero polynomial. That is, equation (2) holds for all $t$ only if $c_0 = \\cdots = c_n = 0$. This proves that $S$ is linearly independent and hence is a basis for $P_n$. The Spanning Set Theorem Let $S = \\lbrace \\vec{v_1}, \\cdots, \\vec{v_p} \\rbrace$ be a set in $V$, and let $H = \\lbrace \\vec{v_1}, \\cdots, \\vec{v_p} \\rbrace$.a. If one of the vectors in $S$-say, $\\vec{v_k}$- is a linear combination of the remaining vectors in $S$, then the set formed from $S$ by removing $\\vec{v_k}$ still spans $H$.b. If $H \\neq \\lbrace \\vec{0}\\rbrace$, some subset of $S$ is a basis for $H$. Bases for Nul A and Col A The pivot columns of a matrix A form a basis for Col A. Two Views of a BasisFor Example: The following three sets in $R^3$ show how a linearly independent set can be enlarged to a basis and how further enlargement destroys the linear independence of the set. Also, a spanning set can be shrunk to a basis, but further shrinking destroys the spanning property. Linearly independent,but does not span $R^3$:$$\\lbrace\\begin{bmatrix}1\\\\0\\\\0\\end{bmatrix},\\begin{bmatrix}2\\\\3\\\\0\\end{bmatrix}\\rbrace$$A basis for $R^3$:$$\\lbrace\\begin{bmatrix}1\\\\0\\\\0\\end{bmatrix},\\begin{bmatrix}2\\\\3\\\\0\\end{bmatrix},\\begin{bmatrix}4\\\\5\\\\6\\end{bmatrix}\\rbrace$$Spans $R^3$ but is linearly dependent:$$\\lbrace\\begin{bmatrix}1\\\\0\\\\0\\end{bmatrix},\\begin{bmatrix}2\\\\3\\\\0\\end{bmatrix},\\begin{bmatrix}4\\\\5\\\\6\\end{bmatrix},\\begin{bmatrix}7\\\\8\\\\9\\end{bmatrix}\\rbrace$$ Coordinate SystemsLet $\\beta = \\lbrace \\vec{b_1}, \\cdots, \\vec{b_n}\\rbrace$ be a basis for a vector space $V$. Then for each $\\vec{x}$ in $V$, there exists a unique set of scalars $c_1, \\cdots, c_n$ such that$$\\vec{x} = c_1\\vec{b_1} + \\cdots + c_n \\vec{b_n}$$ Suppose $\\beta = \\lbrace \\vec{b_1}, \\cdots, \\vec{b_n}\\rbrace$ is a basis for $V$ and $\\vec{x}$ is in $V$. The coordinates of x relative to the basis $\\beta$ (or the $\\beta $-coordinates of x) are the weights $c_1, \\cdots, c_n$ such that$$\\vec{x} = c_1\\vec{b_1} + \\cdots + c_n\\vec{b_n}$$If $c_1, \\cdots, c_n$ are the $\\beta$-coordinates of $\\vec{x}$, then the vector in $R^n$$$[\\vec{x}]_\\beta =\\begin{bmatrix}c_1 \\\\ \\cdots \\\\c_n\\end{bmatrix}$$is the coordinate vector of $\\vec{x}$ (relative to $\\beta$), the mapping $\\vec{x} \\mapsto [\\vec{x}]_\\beta$ is the coordinate mapping (determined by $\\beta$). A Graphical Interpretation of Coordinates1 unit in the $\\vec{e_1}$ direction, 6 units in the $\\vec{e_2}$ direction:$$\\vec{x} =\\begin{bmatrix}1 \\\\ 6\\end{bmatrix}$$2 units in the $\\vec{b_1}$ direction, 3 units in the $\\vec{b_2}$ direction:$$[\\vec{x}]_\\beta =\\begin{bmatrix}-2 \\\\ 3\\end{bmatrix}$$ Coordinates in $R^n$For Example: Let $\\vec{b_1} = \\begin{bmatrix} 2 \\\\ 1 \\end{bmatrix}$,$\\vec{b_2} = \\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix}$,$\\vec{x} = \\begin{bmatrix} 4 \\\\ 5 \\end{bmatrix}$, and $\\beta = \\lbrace \\vec{b_1}, \\vec{b_2}\\rbrace$. Find the coordinate vector $[\\vec{x}]_\\beta$ of $\\vec{x}$ relative to $\\beta$. Solution: The $\\beta$-coordinates $c_1, c_2$ of $\\vec{x}$ satisfy $$c_1\\begin{bmatrix}2 \\\\ 1\\end{bmatrix} + c_2\\begin{bmatrix}-1 \\\\ 1\\end{bmatrix}= \\begin{bmatrix}4 \\\\ 5\\end{bmatrix},\\begin{bmatrix}2 &amp; -1 \\\\ 1 &amp; 1\\end{bmatrix} \\begin{bmatrix}c_1 \\\\ c_2\\end{bmatrix}= \\begin{bmatrix}4 \\\\ 5\\end{bmatrix}\\tag{3}$$ This equation can be solved by row operations on an augmented matrix or by using the inverse of the matrix on the left. In any case, the solution is$$c_1 = 3, c_2 = 2 \\\\\\vec{x} = 3\\vec{b_1} + 2\\vec{b_2}, and \\space[\\vec{x}]_\\beta = \\begin{bmatrix}c_1 \\\\ c_2\\end{bmatrix}=\\begin{bmatrix}3 \\\\ 2\\end{bmatrix}$$ The matrix in (3) changes the $\\beta$ -coordinates of a vector $\\vec{x}$ into the standard coordinates for $\\vec{x}$. An analogous change of coordinates can be carried out in $R^n$ for a basis $\\beta = \\lbrace \\vec{b_1}, \\cdots, \\vec{b_n} \\rbrace$. Let $$P_\\beta =\\begin{bmatrix}\\vec{b_1} &amp; \\vec{b_2} &amp; \\cdots &amp; \\vec{b_n}\\end{bmatrix}$$Then the vector equation $$\\vec{x} = c_1\\vec{b_1} + c_2\\vec{b_2} + \\cdots + c_n\\vec{b_n}$$is equivalent to$$\\vec{x} = P_\\beta[\\vec{x}]_\\beta$$ We call $P_\\beta$ the change-of-coordinates matrix from $\\beta$ to the standard basis in $R^n$. Left-multiplication by $P_\\beta$ transforms the coordinate vector $[\\vec{x}]_\\beta$ into $\\vec{x}$. Since the columns of $P_\\beta$ form a basis for $R^n$, $P_\\beta$ is invertible. Left-multiplication by $P_\\beta^{-1}$converts $\\vec{x}$ into its $\\beta$-coordinate vector: $$P_\\beta^{-1}\\vec{x} = [\\vec{x}]_\\beta$$ The Coordinate MappingChoosing a basis $\\beta = \\lbrace \\vec{b_1}, \\cdots, \\vec{b_n} \\rbrace$ for a vector space $V$ introduces a coordinate system in $V$. The coordinate mapping $\\vec{x} \\mapsto [\\vec{x}]_\\beta$ connects the possibly unfamiliar space $V$ to the familiar space $R^n$: Let $\\beta = \\lbrace \\vec{b_1}, \\cdots, \\vec{b_n} \\rbrace$ be a basis for a vector space $V$. Then the coordinate mapping $\\vec{x} \\mapsto [\\vec{x}]_\\beta$ is a one-to-one linear transformation from $V$ onto $R^n$.这里一定要注意，beta是向量空间V的基向量，x也是属于V空间的向量 Proof: two typical vectors in $V$:$$\\vec{u} = c_1\\vec{b_1} + \\cdots + c_n\\vec{b_n},\\vec{w} = d_1\\vec{b_1} + \\cdots + d_n\\vec{b_n}\\stackrel{addition-operation}\\longrightarrow\\vec{u} + \\vec{w} = (c_1 + d_1)\\vec{b_1} + \\cdots + (c_n + d_n)\\vec{b_n}\\longrightarrow\\\\[\\vec{u} + \\vec{w}]_\\beta =\\begin{bmatrix}c_1 + d_1 \\\\\\cdots \\\\c_n + d_n\\end{bmatrix} =\\begin{bmatrix}c_1 \\\\\\cdots \\\\c_n\\end{bmatrix} +\\begin{bmatrix}d_1 \\\\\\cdots \\\\d_n\\end{bmatrix} =[\\vec{u}]_\\beta + [\\vec{w}]_\\beta\\\\常量乘法也一样性质，略过$$ Thus the coordinate mapping also preserves scalar multiplication and hence is a linear transformation. In general, a one-to-one linear transformation from a vector space $V$ onto a vector space$W$ is called an isomorphism from $V$ onto $W$. For Example: Let $\\beta$ be the standard basis of the space $P_3$ of polynomials; that is, let $\\beta = \\lbrace \\vec{1}, \\vec{t}, \\vec{t^2}, \\vec{t^3}\\rbrace$. A typical element $p$ of $P_3$ has the form: $$\\vec{p(t)} = a_0 + a_1\\vec{t} + a_2\\vec{t^2} + a_3\\vec{t^3}$$Since $\\vec{p}$is already displayed as a linear combination of the standard basis vectors, weconclude that:$$[\\vec{p}]_\\beta =\\begin{bmatrix}a_0\\\\a_1\\\\a_2\\\\a_3\\end{bmatrix}$$ Thus the coordinate mapping $\\vec{p} \\mapsto [\\vec{p}]_\\beta$is an isomorphism from$P_3$ onto $R_4$. The Dimension of A Vector Space If a vector space $V$ has a basis $\\beta = \\lbrace \\vec{b_1}, \\cdots, \\vec{b_n}\\rbrace$, then any set in $V$ containing more than $n$ vectors must be linearly dependent. If a vector space $V$ has a basis of $n$ vectors, then every basis of $V$ must consist of exactly $n$ vectors. If $V$ is spanned by a finite set, then $V$ is said to be finite-dimensional, and the dimension of $V$ , written as $dim V$ , is the number of vectors in a basis for $V$ . The dimension of the zero vector space ${\\vec{0}}$ is defined to be zero. If $V$ is not spanned by a finite set, then V is said to be infinite-dimensional. For Example: Find the dimension of the subspace:$H = \\lbrace \\begin{bmatrix} a - 3b + 6c\\\\5a + 4d\\\\ b - 2c - d\\\\5d\\end{bmatrix} a,b,c,d \\space in R \\rbrace$ Solution: $H$ is the set of all linear combinations of the vectors:$$\\vec{v_1} =\\begin{bmatrix}1\\\\5\\\\0\\\\0\\end{bmatrix},\\vec{v_2} =\\begin{bmatrix}-3\\\\0\\\\1\\\\0\\end{bmatrix},\\vec{v_3} =\\begin{bmatrix}6\\\\0\\\\-2\\\\0\\end{bmatrix},\\vec{v_4} =\\begin{bmatrix}0\\\\4\\\\-1\\\\5\\end{bmatrix}$$ $\\lbrace \\vec{v_1}, \\vec{v_2}, \\vec{v_4}\\rbrace$ is linearly independent and hence is a basis for $H$. Thus $dim H = 3$. Subspaces of a Finite-Dimensional SpaceLet $H$ be a subspace of a finite-dimensional vector space $V$ . Any linearly independent set in $H$ can be expanded, if necessary, to a basis for $H$ . Also, $H$ is finite-dimensional and $$dim H \\leqslant dim V$$ The Dimensions of $Nul A$ and $Col A$ The dimension of $Nul A$ is the number of free variables in the equation $A\\vec{x} = \\vec{0}$, and the dimension of $Col A$ is the number of pivot columns in $A$. For Example: Find the dimensions of the null space and the column space of $A = \\begin{bmatrix}-3 &amp; 6 &amp; -1 &amp; 1 &amp; -7\\\\1 &amp; -2 &amp; 2 &amp; 3 &amp; -1\\\\2 &amp; -4 &amp; 5 &amp; 8 &amp; -4\\end{bmatrix}$ $$\\begin{bmatrix}1 &amp; -2 &amp; 2 &amp; 3 &amp; -1 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 2 &amp; -2 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\end{bmatrix}\\x_2, x_4, x_5: free\\space variables\\\\\\longrightarrow dimNulA = 3, dimColA = 2.$$ RankThe Row Space If two matrices $A$ and $B$ are row equivalent, then their row spaces are the same. If $B$ is in echelon form, the nonzero rows of $B$ form a basis for the row space of $A$ as well as for that of $B$. For Example: Find bases for the row space, the column space, and the null space of the matrix $\\begin{bmatrix}-2 &amp; -5 &amp; 8 &amp; 0 &amp; -17\\\\1 &amp; 3 &amp; -5 &amp; 1 &amp; 5\\\\3 &amp; 11 &amp; -19 &amp; 7 &amp; 1\\\\1 &amp; 7 &amp; -13 &amp; 5 &amp; -3\\end{bmatrix}$. $$A \\sim B =\\begin{bmatrix}1 &amp; 3 &amp; -5 &amp; 1 &amp; 5\\\\0 &amp; 1 &amp; -2 &amp; 2 &amp; -7\\\\0 &amp; 0 &amp; 0 &amp; -4 &amp; 20\\\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\end{bmatrix}\\sim C =\\begin{bmatrix}1 &amp; 0 &amp; 1 &amp; 0 &amp; 1\\\\0 &amp; 1 &amp; -2 &amp; 0 &amp; 3\\\\0 &amp; 0 &amp; 0 &amp; 1 &amp; -5\\\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\end{bmatrix}\\\\（只需看前几行非零）Basis-for-RowA:\\lbrace(1, 3, 5, 1, 5),(0, 1, 2, 2, 7),(0, 0, 0, 4, 20)\\rbrace\\\\（要看pivot \\space columns）Basis-for-ColA:\\lbrace\\begin{bmatrix}-2\\\\ 1\\\\ 3\\\\ 1\\end{bmatrix},\\begin{bmatrix}-5\\\\ 3\\\\ 11\\\\ 7\\end{bmatrix},\\begin{bmatrix}0\\\\ 1\\\\ 7\\\\ 5\\end{bmatrix}\\rbrace\\\\（求解，有两个自由变量）Basis-for-NullA:\\lbrace\\begin{bmatrix}-1\\\\ 2\\\\ 1\\\\ 0\\\\ 0\\end{bmatrix},\\begin{bmatrix}-1\\\\ -3\\\\ 0\\\\ 5\\\\ 1\\end{bmatrix}\\rbrace$$ The Rank Theorem The rank of $A$ is the dimension of the column space of $A$. The dimensions of the column space and the row space of an $m \\times n$ matrix $A$ are equal. This common dimension, the rank of $A$, also equals the number of pivot positions in $A$ and satisfies the equation $$rank A + dim NullA = n\\\\其实就是：\\\\\\lbrace number-of-pivot-columns\\rbrace +\\lbrace number-of-nonpivot-columns\\rbrace =\\lbrace number-of-columns\\rbrace$$ Applications to Systems of EquationsFor Example: A scientist has found two solutions to a homogeneous system of 40 equations in 42 variables. The two solutions are not multiples, and all other solutions can be constructed by adding together appropriate multiples of these two solutions. Can the scientist be certain that an associated nonhomogeneous system (with the same coefficients) has a solution? Solution: Yes. Let $A$ be the $40 \\times 42$ coefficient matrix of the system. The given information implies that the two solutions are linearly independent and span $Nul A$.So $dim Nul A = 2$. By the Rank Theorem, $dim Col A = 42 - 2 = 40$. Since $R^{40}$ is the only subspace of $R^{40}$ whose dimension is $40$, $Col A$ must be all of $R^{40}$. This means that every nonhomogeneous equation $Ax = b$ has a solution. Rank and the Invertible Matrix Theorem The Invertible Matrix TheoremLet $A$ be an $n \\times n$ matrix. Then the following statements are each equivalent to the statement that $A$ is an invertible matrix.m.The columns of $A$ form a basis of $R^n$.n. $Col A = R^n$o. $dim Col A = n$p. $rank A = n$q. $Nul A = \\lbrace 0 \\rbrace $r. $dim Nul A = 0$ Change of BasisFor Example: Consider two bases $\\beta = \\lbrace \\vec{b_1}, \\vec{b_2}\\rbrace$ and $\\gamma = \\lbrace \\vec{c_1}, \\vec{c_2}\\rbrace$ for a vector space $V$, such that $$\\vec{b_1} = 4 \\vec{c_1} + \\vec{c_2} \\space and \\space \\vec{b_2} = -6 \\vec{c_1} + \\vec{c_2}\\tag{1}$$ Suppose $$\\vec{x} = 3\\vec{b_1} + \\vec{b_2}\\tag{2}$$ That is, suppose $[\\vec{x}]_\\beta = \\begin{bmatrix}3\\\\1\\end{bmatrix}$. Find $[\\vec{x}]_\\gamma$. Solution: Apply the coordinate mapping determined by $\\gamma$ to $\\vec{x}$ in (2). Since the coordinate mapping is a linear transformation. $$[\\vec{x}]_\\gamma = [3\\vec{b_1}+\\vec{b_2}]_\\gamma= 3[\\vec{b_1}]_\\gamma+[\\vec{b_2}]_\\gamma$$ We can write this vector equation as a matrix equation, using the vectors in the linear combination as the columns of a matrix: $$[\\vec{x}]_\\gamma =\\begin{bmatrix}[\\vec{b_1}]_\\gamma &amp; [\\vec{b_2}]_\\gamma\\end{bmatrix}\\begin{bmatrix}3\\\\ 1\\end{bmatrix}$$ From (1), $$[\\vec{b_1}]_\\gamma =\\begin{bmatrix}4\\\\ 1\\end{bmatrix},[\\vec{b_2}]_\\gamma =\\begin{bmatrix}-6\\\\ 1\\end{bmatrix}$$ Thus, $$[\\vec{x}]_\\gamma =\\begin{bmatrix}4 &amp; -6\\\\1 &amp; 1\\end{bmatrix}\\begin{bmatrix}3\\\\ 1\\end{bmatrix}=\\begin{bmatrix}6\\\\ 4\\end{bmatrix}$$ Let $\\beta = \\lbrace \\vec{b_1}, \\cdots, \\vec{b_n}\\rbrace$ and $\\gamma = \\lbrace \\vec{c_1}, \\cdots, \\vec{c_n}\\rbrace$ be bases of a vector space $V$. Then there is a unique $n \\times n$ matrix $\\gamma \\stackrel{P}\\leftarrow \\beta$ such that $$[\\vec{x}]_\\gamma =\\gamma \\stackrel{P}\\leftarrow \\beta [\\vec{x}]_\\beta$$ The columns of $\\gamma \\stackrel{P}\\leftarrow \\beta$ are the $\\gamma$-coordinate vectors of the vectors in the basis $\\beta$. That is, $$\\gamma \\stackrel{P}\\leftarrow \\beta =\\begin{bmatrix}[\\vec{b_1}]\\gamma &amp; [\\vec{b_2}]\\gamma \\cdots [\\vec{b_n}]\\gamma\\end{bmatrix}$$ $\\gamma \\stackrel{P}\\leftarrow \\beta$ is called the change-of-coordinates matrix from $\\beta$ to $\\gamma$.Multiplication by $\\gamma \\stackrel{P}\\leftarrow \\beta$ converts $\\beta$-coordinates into $\\gamma$-coordinates. Change of Basis in $R^n$For Example: Let $\\vec{b_1} = \\begin{bmatrix}-9\\\\1\\end{bmatrix}$,$\\vec{b_2} = \\begin{bmatrix}-5\\\\-1\\end{bmatrix}$,$\\vec{c_1} = \\begin{bmatrix}1\\\\-4\\end{bmatrix}$,$\\vec{c_2} = \\begin{bmatrix}3\\\\-5\\end{bmatrix}$, and consider the bases for $R^2$ given by $\\beta = \\lbrace \\vec{b_1}, \\vec{b_2}\\rbrace$ and $\\gamma = \\lbrace \\vec{c_1}, \\vec{c_2}\\rbrace$. Find the change-of-coordinates matrix from $\\beta$ to $\\gamma$. Solution: The matrix $\\gamma \\stackrel{P}\\leftarrow \\beta$ involves the $\\gamma$-coordinate vectors of $\\vec{b_1}$ and $\\vec{b_2}$. Let $[\\vec{b_1}_\\gamma] = \\begin{bmatrix}x_1\\\\x_2\\end{bmatrix}$ and $[\\vec{b_2}_\\gamma] = \\begin{bmatrix}y_1\\\\y_2\\end{bmatrix}$. Then, by definition, $$\\begin{bmatrix}\\vec{c_1} &amp; \\vec{c_2}\\end{bmatrix}\\begin{bmatrix}\\vec{x_1} \\\\ \\vec{x_2}\\end{bmatrix}=\\vec{b_1} \\space and \\space\\begin{bmatrix}\\vec{c_1} &amp; \\vec{c_2}\\end{bmatrix}\\begin{bmatrix}\\vec{y_1} \\\\ \\vec{y_2}\\end{bmatrix}=\\vec{b_2}$$ To solve both systems simultaneously, augment the coefficient matrix with $\\vec{b1}$ and $\\vec{b2}$, and row reduce: $$\\left[ \\begin{array}{cc|c} \\vec{c_1} &amp; \\vec{c_2} &amp; \\vec{b_1} &amp; \\vec{b_2}\\end{array}\\right] =\\left[ \\begin{array}{cc|cc} -1 &amp; 3 &amp; -9 &amp; -5 \\\\ -4 &amp; -5 &amp; 1 &amp; -1\\end{array}\\right]\\sim\\left[ \\begin{array}{cc|cc} 1 &amp; 0 &amp; 6 &amp; 4 \\\\ 0 &amp; 1 &amp; -5 &amp; -3\\end{array}\\right]$$ Thus $$[\\vec{b_1}]_\\gamma =\\begin{bmatrix}6 \\\\ -5\\end{bmatrix}\\space and \\space[\\vec{b_2}]_\\gamma =\\begin{bmatrix}4 \\\\ -3\\end{bmatrix}$$ The desired change-of-coordinates matrix is therefore $$\\gamma \\stackrel{P}\\leftarrow \\beta=\\begin{bmatrix}[\\vec{b_1}]_\\gamma &amp; [\\vec{b_2}]_\\gamma\\end{bmatrix}=\\begin{bmatrix}6 &amp; 4 \\\\ -5 &amp; -3\\end{bmatrix}$$ An analogous procedure works for finding the change-of-coordinates matrix between any two bases in $R^n$: $$\\left[ \\begin{array}{cc|c} \\vec{c_1} &amp; \\vec{c_2} &amp; \\vec{b_1} &amp; \\vec{b_2}\\end{array}\\right]\\sim\\left[ \\begin{array}{c|c} I &amp; \\gamma \\stackrel{P}\\leftarrow \\beta \\end{array}\\right]$$ the change-ofcoordinate matrices $P_\\beta$ and $P_\\gamma$ that convert $\\beta$-coordinates and $\\gamma$-coordinates, respectively, into standard coordinates. $$P_\\beta[\\vec{x}]_\\beta = \\vec{x}, \\spaceP_\\gamma[\\vec{x}]_\\gamma = \\vec{x}, \\space and \\space[\\vec{x}]_\\gamma = P_\\gamma^{-1}\\vec{x}$$ Thus, $$[\\vec{x}]_\\gamma = P_\\gamma^{-1}\\vec{x} = P_\\gamma^{-1}P_\\beta[\\vec{x}]_\\beta\\\\\\Rightarrow\\\\\\gamma \\stackrel{P}\\leftarrow \\beta = P_\\gamma^{-1}P_\\beta$$ More about Coordinates Space and Transformations in Graphics &gt;&gt; Applications to Difference Equation差分方程Linear Independence in the Space $S$ of Signalswe consider a set of only three signals in $S$, say, $\\lbrace u_k \\rbrace,\\lbrace v_k \\rbrace,\\lbrace w_k \\rbrace$.They are linearly independent precisely when the equation $$c_1 u_k + c_2 v_k + c_3 w_k = 0 for\\space all \\space k\\tag{1}$$ implies that $c1 = 0, c2 = 0, c3 = 0$.Then equation (1) holds for any three consecutive values of $k$, say, $k, k + 1, \\space and \\space k + 2$.Hence $c1, c2, c3$ satisfy $$\\begin{bmatrix}u_k &amp; v_k &amp; w_k\\\\u_{k+1} &amp; v_{k+1} &amp; w_{k+1}\\\\u_{k+2} &amp; v_{k+2} &amp; w_{k+2}\\end{bmatrix}\\begin{bmatrix}c_1\\\\c_2\\\\c_3\\\\\\end{bmatrix}=\\begin{bmatrix}0\\\\0\\\\0\\end{bmatrix}\\tag{2}$$ The coefficient matrix in this system is called the Casorati matrix of the signals, and the determinant of the matrix is called the Casoratian of $u_k, v_k, w_k$. If the Casorati matrix is invertible for at least one value of k, then (2) will imply that $c1 = c2 = c3 = 0$, which will prove that the three signals are linearly independent. For Example: Verify that $1^k, (-2)^k, and \\space 3^k$ are linearly independent signals. Solution: The Casorati matrix is: $$\\begin{bmatrix}1^k &amp; (-2)^k &amp; 3^k\\\\1^{k+1} &amp; (-2){k+1} &amp; 3^{k+1}\\\\1^{k+2} &amp; (-2)^{k+2} &amp; 3^{k+2}\\end{bmatrix}$$ The Casorati matrix is invertible for $k = 0$. So $1^k, (-2)^k, 3^k$ are linearly independent. Linear Difference Equations（线性差分方程）Given scalars $a_0,\\cdots, a_n$, with $a_0$ and $a_n$ nonzero, and given a signal $\\lbrace z_k \\rbrace$, the equation $$a_0y_{k+n} + a_1y_{k+n-1} + \\cdots + a_ny_k = z_k for\\space all\\space k \\tag{3}$$ is called a linear difference equation (or linear recurrence relation) of order $n$. For simplicity, $a_0$ is often taken equal to 1. If $\\lbrace z_k \\rbrace$ is the zero sequence, the equation is homogeneous; otherwise, the equation is nonhomogeneous. 在第一章节的笔记中，有提一嘴Fibonacci数列是差分方程，具体形式如下,为什么看起来是差分方程的定义不太一样？（接着看下面的内容） $$\\vec{x_{k+1}} = A\\vec{x_k}, k = 0,1,2,…\\tag{5}$$ $$Fibonacci\\\\f(0) = 0, f(1) = 1\\\\f(n) = f(n-1) + f(n-2), n &gt; 1$$建立矩阵方程如下：$$let \\space F(n) = \\begin{bmatrix}f(n) \\\\ f(n+1)\\end{bmatrix}\\\\AF(n) = F(n+1)\\rightarrowA\\begin{bmatrix}f(n) \\\\ f(n+1)\\end{bmatrix} =\\begin{bmatrix}f(n+1) \\\\ f(n+2)\\end{bmatrix}\\\\\\rightarrowA = \\begin{bmatrix}0 &amp; 1 \\\\ 1 &amp; 1\\end{bmatrix}\\\\\\RightarrowF(n) = A^nF(0), F(0) = \\begin{bmatrix}0 \\\\ 1\\end{bmatrix}$$ For Example: In digital signal processing, a difference equation such as (3) describes a linear filter, and $a_0,\\cdots, a_n$ are called the filter coefficients. If $\\lbrace y_k \\rbrace$ is treated as the input and $\\lbrace z_k \\rbrace$ as the output, then the solutions of the associated homogeneous equation are the signals that are filtered out and transformed into the zero signal. Let us feed two different signals into the filter $$0.35y_{k+2} + 0.5y_{k+1} + 0.35y_k = z_k$$ Here $0.35$ is an abbreviation for $\\sqrt2/4$. The first signal is created by sampling the continuous signal $y = \\cos(\\pi t / 4)$at integer values of $t$, as in Figure3(a). The discrete signal is $$\\lbrace y_k\\rbrace = \\lbrace \\cdots, \\cos(0), \\cos(\\pi/4), cos(2\\pi/4), cos(3\\pi/4), \\cdots\\rbrace$$ For simplicity, write $\\pm0.7$ in place of $\\pm\\sqrt2/2$, so that $$\\lbrace y_k\\rbrace = \\lbrace \\cdots, 1, 0.7, 0, -0.7,-1,-0.7,0,0.7,1,0.7,0 \\cdots\\rbrace$$ Table 1 shows a calculation of the output sequence $\\lbrace z_k \\rbrace$, where $0.35\\cdot0.7$ is an abbreviation for $(\\sqrt2/4)(\\sqrt2/2)=0.25$. The output is $\\lbrace y_k\\rbrace$, shifted by one term. A different input signal is produced from the higher frequency signal $y = \\cos(3\\pi/4)$, shown in Figure 3(b). Sampling at the same rate as before produces a new input sequence: $$\\lbrace y_k\\rbrace = \\lbrace \\cdots, 1, -0.7, 0, 0.7, -1, 0.7, 0 \\cdots\\rbrace$$ When $\\lbrace w_k\\rbrace$ is fed into the filter, the output is the zero sequence. The filter, called a low-pass filter（低通滤波器）, lets $\\lbrace y_k \\rbrace$ pass through, but stops the higher frequency $\\lbrace w_k \\rbrace$. In many applications, a sequence $\\lbrace z_k \\rbrace$ is specified for the right side of a difference equation (3), and a $\\lbrace y_k \\rbrace$ that satisfies (3) is called a solution of the equation. The next example shows how to find solutions for a homogeneous equation. （比如机器学习就类似于如此，给定输入和输出，学习最优权重） For Example: Solutions of a homogeneous difference equation often have the form $y_k = r^k$ for some $r$. Find some solutions of the equation $$y_{k+3} - 2y_{k+2} - 5y_{k+1} + 6y_k = 0 , for\\space all\\space k$$ Solution: Substitute $r^k$ for $y_k$ in the equation and factor the left side: $$r^{k+3} - 2r^{k+2} - 5r^{k+1} + 6r^{k} = 0\\rightarrowr^k(r-1)(r+2)(r-3) = 0$$ Thus, $(1)^k, (-2)^k, (3)^k$ are all solutions. In general, a nonzero signal $r^k$ satisfies the homogeneous difference equation $$y_{k+n} + a_1y_{k+n-1} + \\cdots + a_ny_k = 0 for\\space all\\space k $$ if and only if $r$ is a root of the auxiliary equation（辅助方程） $$r^n + a_1r^{n-1} + \\cdots + a_{n-1}r + a_n = 0$$ Solution Sets of Linear Difference Equationsif $a_n \\neq 0$ and if $\\lbrace z_k \\rbrace$ is given, the equation $$y_{k+n} + a_1y_{k+n-1} + \\cdots + a_{n-1}y_{k+1} + a_ny_k = z_k, for\\space all\\space k$$ has a unique solution whenever $y_0, \\cdots, y_{n-1}$ are specified. The set $H$ of all solutions of the nth-order homogeneous linear difference equation $$y_{k+n} + a_1y_{k+n-1} + \\cdots + a_{n-1}y_{k+1} + a_ny_k = 0, for\\space all\\space k$$ is an $n$-dimensional vector space. Nonhomogeneous Equations（非齐次差分方程）The general solution of the nonhomogeneous difference equation $$y_{k+n} + a_1y_{k+n-1} + \\cdots + a_{n-1}y_{k+1} + a_ny_k = z_k, for\\space all\\space k$$ For Example: Verify that the signal $y_k = k^2$ satisfies the difference equation $$y_{k+2} - 4y_{k+1} + 3y_k = -4k, for\\space all\\space k\\tag{12}$$ Then find a description of all solutions of this equation. Solution: Substitute $k^2$ for $y_k$ on the left side of (12): $$(k+2)^2-4(k+1)^2+3k^2 = -4k$$ so $k^2$is indeed a solution of (12). The next step is to solve the homogeneous equation $$y_{k+2} - 4y_{k+1} + 3y_k = 0, for\\space all\\space k\\tag{13}$$ The auxiliary equation is $$r^2 -4r + 3 = (r-1)(r+3) = 0$$ The roots are $r = 1,3$.So two solutions of the homogeneous difference equation are $1^k$ and $3^k$. They are obviously not multiples of each other, so they are linearly independent signals. the solution space is two-dimensional, so 3k and 1k form a basis for the set of solutions of equation (13).Translating that set by a particular solution of the nonhomogeneous equation (12), we obtain the general solution of (12): $$k^2 + c_1 1^k + c_2 3^k, or \\space k^2 + c_1 + c_23^k$$ Figure 4 gives a geometric visualization of the two solution sets. Each point in the figure corresponds to one signal in S. Reduction to Systems of First-Order Equations（约简到一阶方程组） 接下来可以解释Fibonacci数列是差分方程 $$AF(n) = F(n+1)\\rightarrowA\\begin{bmatrix}f(n)\\\\f(n+1)\\end{bmatrix} =\\begin{bmatrix}f(n+1)\\\\f(n+2)\\end{bmatrix}\\$$ A modern way to study a homogeneous $nth$-order linear difference equation is to replace it by an equivalent system of first-order difference equations, written in the form $$\\vec{x_{k+1}} = A\\vec{x_{k}}, for \\space all\\space k$$ where the vectors $\\vec{x_{k}}$ are in $R^n$ and $A$ is an $n \\times n$ matrix. For Example: Write the following difference equation as a first-order system: $$y_{k+3} - 2y_{k+2} - 5y_{k+1} + 6y_k = 0, for \\space all\\space k$$ Solution: for each k, set $$\\vec{x_k} =\\begin{bmatrix}y_k\\\\y_{k+1}\\\\y_{k+2}\\end{bmatrix}$$ The difference equation says that $y_{k+3} - 2y_{k+2} - 5y_{k+1} + 6y_k = 0$, so $$\\vec{x_{k+1}} =\\begin{bmatrix}y_{k+1} \\\\ y_{k+2} \\\\ y_{k+3}\\end{bmatrix} =\\begin{bmatrix}0 + y_{k+1} + 0\\\\0 + 0 + y_{k+2}\\\\-6y_k + 5y_{k+1} + 2y_{k+2}\\end{bmatrix} =\\begin{bmatrix}0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 1\\\\-6 &amp; 5 &amp; 2\\end{bmatrix}\\begin{bmatrix}y_{k}\\\\y_{k+1}\\\\y_{k+2}\\end{bmatrix}$$ That is, $$\\vec{x_{k+1}} = A\\vec{x_{k}}, for \\space all\\space k , whereA =\\begin{bmatrix}0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 1\\\\-6 &amp; 5 &amp; 2\\end{bmatrix}$$ In general, the equation $$y_{k+n} + a_1y_{k+n-1} + \\cdots + a_{n-1}y_{k+1} + a_ny_k = 0, for\\space all\\space k$$ can be written as $\\vec{x_{k+1}} = A\\vec{x_{k}}, for \\space all\\space k$, where $$\\vec{x_{k}} = \\begin{bmatrix}y_{k}\\\\ y_{k+1} \\\\ \\cdots \\\\ y_{k+n-1} \\end{bmatrix},A = \\begin{bmatrix}0 &amp; 1 &amp; 0 &amp; \\cdots &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; \\cdots &amp; 0\\\\\\cdots\\\\0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 1\\\\-a_n &amp; -a_{n-1} &amp; -a_{n-2} &amp; \\cdots &amp; -a_1\\end{bmatrix}$$ Applications to Markov ChainsFor example, if the population of a city and its suburbs were measured each year, then a vector such as $$\\vec{x_0} =\\begin{bmatrix}0.60\\\\0.40\\end{bmatrix}\\tag{1}$$ could indicate that 60% of the population lives in the city and 40% in the suburbs. The decimals in $\\vec{x_0}$ add up to 1 because they account for the entire population of the region.Percentages are more convenient for our purposes here than population totals. A vector with nonnegative entries that add up to 1 is called a probability vector（概率向量）. A stochastic matrix（随机矩阵） is a square matrix whose columns are probability vectors. A Markov chain（马尔科夫链） is a sequence of probability vectors $\\vec{x_0}, \\vec{x_1}, \\vec{x_2}$ together with a stochastic matrix $P$ , such that $$\\vec{x_1} = P\\vec{x_0}, \\vec{x_2} = P\\vec{x_1}, \\vec{x_3} = P\\vec{x_2}, \\cdots\\\\\\longrightarrow\\vec{x_{k+1}} = P\\vec{x_k}$$ $\\vec{x_k}$ is often called a state vector（状态向量. Predicting the Distant FutureFor Example: Let $P = \\begin{bmatrix}0.5 &amp; 0.2 &amp; 0.3\\\\0.3 &amp; 0.8 &amp; 0.3\\\\0.2 &amp; 0 &amp; 0.4\\end{bmatrix}$ and $\\vec{x_0} = \\begin{bmatrix}1\\\\0\\\\0\\end{bmatrix}$. Consider a system whose state is described by the Markov chain $\\vec{x_{k+1}} = P\\vec{x_{k}}, for k = 0,1,\\cdots$ What happens to the system as time passes? Compute the state vectors $\\vec{x_1},\\cdots, \\vec{x_{15}}$to find out. Solution:$$\\vec{x_1} = P\\vec{x_0} = \\begin{bmatrix}0.5\\\\0.3\\\\0.2\\end{bmatrix},\\\\\\\\\\cdots\\\\\\vec{x_{14}} = P\\vec{x_{13}} = \\begin{bmatrix}0.3001\\\\0.59996\\\\0.10002\\end{bmatrix},\\\\\\vec{x_{15}} = P\\vec{x_{14}} = \\begin{bmatrix}0.3001\\\\0.59998\\\\0.10001\\end{bmatrix}$$These vectors seem to be approaching $\\vec{q} = \\begin{bmatrix}0.3\\\\0.6\\\\0.1\\end{bmatrix}$The probabilities are hardly changing from one value of $k$ to the next. $$P\\vec{q} = \\begin{bmatrix}0.5 &amp; 0.2 &amp; 0.3\\\\0.3 &amp; 0.8 &amp; 0.3\\\\0.2 &amp; 0 &amp; 0.4\\end{bmatrix}\\begin{bmatrix}0.3\\\\0.6\\\\0.1\\end{bmatrix}=\\begin{bmatrix}0.3\\\\0.6\\\\0.1\\end{bmatrix}=\\vec{q}$$When the system is in state $q$, there is no change in the system from one measurement to the next. Steady-State VectorsIf $P$ is a stochastic matrix, then a steady-state vector (or equilibrium vector（平衡向量）) for $P$ is a probability vector $\\vec{q}$ such that $$P\\vec{q} = \\vec{q}$$ For Example: Let $P = \\begin{bmatrix} 0.6 &amp; 0.3 \\ 0.4 &amp; 0.7\\end{bmatrix}$. Find a steady-state vector for $P$. Solution:$$P\\vec{x} = \\vec{x}\\rightarrow (P-I)\\vec{x} = \\vec{0}\\\\longrightarrow\\begin{bmatrix}-0.4 &amp; 0.3 &amp; 0 \\\\0.4 &amp; -0.3 &amp; 0\\end{bmatrix}\\sim\\begin{bmatrix}1 &amp; -3/4 &amp; 0 \\\\0 &amp; 0 &amp; 0\\end{bmatrix}$$$$\\vec{x} = x_2\\begin{bmatrix}3/4 \\\\ 1\\end{bmatrix}$$ Obviously, One obvious choice is $\\begin{bmatrix}3/4 \\\\ 1\\end{bmatrix}$,but a better choice with no fractions is $\\vec{w} = \\begin{bmatrix}3 \\\\ 4\\end{bmatrix}, (x_2 = 4)$, since every solution is a multiple of the solution$\\vec{w}$ above. Divide $\\vec{w}$ by the sum of its entries and obtain $$\\vec{q} = \\begin{bmatrix}3/7 \\\\ 4/7\\end{bmatrix}$$ if $P$ is an $n\\times n$ regular stochastic matrix, then $P$ has a unique steady-state vector $\\vec{q}$. Further, if $\\vec{x_0}$ is any initial state and $\\vec{x_{k+1}} = P \\vec{x_k}$, then the Markov chain $\\vec{x_k}$ converges to $\\vec{q}$ as $k \\rightarrow \\infty$. Also, $\\vec{q}$ is the eigenvector of $P$. See C5 ReadingNotes.","link":"/Math/Linear-Algebra/C4-Vector-Spaces/"},{"title":"C3-Determinants","text":"Keywords: Determinants, Linear Transformation, Area or Volume, Cramer’s Rule Introduction to Determinants If $A$ is a triangular matrix, then det $A$ is the product of the entries on the main diagonal of $A$. The determinant of an $n \\times n$ matrix $A$ can be computed by a cofactor expansion across any row or down any column. The expansion across the $i-th$ row using the cofactors is $$\\begin{aligned}det A &amp;= a_{i1}C_{i1} + a_{i2}C_{i2} + \\cdots + a_{in}C_{in}\\\\C_{ij} &amp;= (-1)^{i+j}detA_{i,j}\\end{aligned}$$ 在计算机中是怎么计算行列式的？Yet it would be impossible to calculate a $25 \\times 25$ determinant by cofactor expansion.In general, a cofactor expansion requires more than $n!$ multiplications, and $25!$ is approximately $1.5 * 10 ^ {25}$ If a computer performs one trillion multiplications per second, it would have to run for more than $500,000 years$ to compute a $25 \\times 25$ determinant by this method. Fortunately, there are faster methods, see the next chapter. Properties of Deternimants Let $A$ be a square matrix.a. If a multiple of one row of $A$ is added to another row to produce a matrix $B$, then $det B = det A$.b. If two rows of $A$ are interchanged to produce $B$, then $det B = - det A$.c. If one row of $A$ is multiplied by $k$ to produce $B$, then $det B = k * det A$. For example: Compute $det A$, where $A = \\begin{bmatrix}2 &amp; -8 &amp; 6 &amp; 8\\\\ 3 &amp; -9 &amp; 5 &amp; 10\\\\ -3 &amp; 0 &amp; 1 &amp; -2\\\\1 &amp; -4 &amp; 0 &amp; 6\\end{bmatrix}$ Solution: 求行列式如下：$$det A = 2\\left|\\begin{array}{} 1 &amp; -4 &amp; 3 &amp; 4 \\\\ 3 &amp; -9 &amp; 5 &amp; 10\\\\ -3 &amp; 0 &amp; 1 &amp; -2\\\\ 1 &amp; -4 &amp; 0 &amp; 6\\end{array}\\right|=2\\left|\\begin{array}{} 1 &amp; -4 &amp; 3 &amp; 4 \\\\ 0 &amp; 3 &amp; -4 &amp; -2\\\\ 0 &amp; 0 &amp; -6 &amp; 2\\\\ 0 &amp; 0 &amp; 0 &amp; 1\\end{array}\\right|=2\\cdot (1)\\cdot(3)\\cdot(-6)\\cdot(1)= -36$$ A square matrix $A$ is invertible if and only if $det A \\neq$ 0 (因为阶梯式下，对角线上如果有0，矩阵肯定不可逆) $$det A = \\begin{cases}(-1)^r \\cdot (product\\space of \\space pivots\\space in \\space U) &amp; when \\space A \\space is\\space invertible\\\\0 &amp; when \\space A \\space is\\space not \\space invertible\\end{cases}\\tag{1}\\\\U = \\begin{bmatrix}\\blacksquare &amp; * &amp; * &amp; * \\\\0 &amp; \\blacksquare &amp; * &amp; * \\\\0 &amp; 0 &amp; \\blacksquare &amp; * \\\\0 &amp; 0 &amp; 0 &amp; \\blacksquare\\end{bmatrix}$$ $r$: interchange operations in the process of matrix $A \\rightarrow U$ . Most computer programs that compute $det A$ for a general matrix $A$ use the method of formula (1) above. It can be shown that evaluation of an $n \\times n$ determinant using row operations requires about $2n^3 / 3$ arithmetic operations. Any modern microcomputer can calculate a $25 \\times 25$ determinant in a fraction of a second, since only about $10,000$ operations are required. Column Operations If $A$ is an $n \\times n$ matrix, then $det A^T = det A$ Determinants and Matrix Products If $A$ and $B$ are $n \\times n$ matrices, then $det AB = detA \\cdot detB$. A Linearity Property of the Determinant Function$$A = \\begin{bmatrix}\\vec{a_1} &amp; \\cdots &amp; \\vec{a_{j-1}} &amp; \\vec{x}&amp; \\vec{a_{j+1}} &amp; \\cdots &amp; \\vec{a_n}\\end{bmatrix}\\\\T(\\vec{x}) = det \\begin{bmatrix}\\vec{a_1} &amp; \\cdots &amp; \\vec{a_{j-1}} &amp; \\vec{x}&amp; \\vec{a_{j+1}} &amp; \\cdots &amp; \\vec{a_n}\\end{bmatrix}\\\\T(c\\vec{x}) = cT(\\vec{x})\\\\T(\\vec{u}+\\vec{v}) = T(\\vec{u}) + T(\\vec{v})$$ Cramer’s Rule, Volume, Linear TransformationCramer’s Rule（克拉默法则）Let A be an invertible $n \\times n$ matrix. For any $\\vec{b}$ in $R^n$, the unique solution $\\vec{x}$ of $A\\vec{x} = \\vec{b}$ has entries given by $$\\vec{x_i} = \\frac{det A_i(\\vec{b})}{det A}, i = 1, 2, \\cdots, n$$$$det A_i(\\vec{b}) =\\begin{bmatrix}\\vec{a_1} &amp; \\cdots &amp; \\vec{b} &amp; \\cdots &amp; \\vec{a_n}\\end{bmatrix}第i列的向量改成了\\vec{b}向量$$ Application to EngineeringLaplace transforms: This approach converts an appropriate system of linear differential equations into a system of linear algebraic equations whose coefficients involve a parameter.（只是提一嘴拉普拉斯变换） For example: Consider the following system in which $s$ is an unspecified parameter. Determine the values of $s$ for which the system has a unique solution, and use Cramer’s rule to describe the solution. $$\\begin{cases}3s x_1 - 2x_1 = 4\\\\-6x_1 + sx_2 = 1\\end{cases}$$ Solution：$$A = \\begin{bmatrix}3s &amp; -2\\\\-6 &amp; s\\end{bmatrix},A_1(\\vec{b}) = \\begin{bmatrix}4 &amp; -2\\\\1 &amp; s\\end{bmatrix},A_2(\\vec{b}) = \\begin{bmatrix}3s &amp; 4\\\\-6 &amp; 1\\end{bmatrix}$$Since,$$det A = 3s^2-12 = 3(s+2)(s-2)$$so,$$unique-solution: s \\neq \\pm2\\\\x_1 = \\frac{det A_1(\\vec{b})}{det A} = \\frac{4s+2}{3(s+2)(s-2)},x_1 = \\frac{det A_2(\\vec{b})}{det A} = \\frac{s+8}{(s+2)(s-2)}$$ A Formula for $A^{–1}$let $A$ be an invertible $n \\times n$ matrix. Then$$A^{-1} = \\frac{1}{det A} adj A$$The adjugate matrix is the transpose of the matrix of cofactors For example: Find the inverse matrix of $A = \\begin{bmatrix}2 &amp; 1 &amp; 3\\\\1 &amp; -1 &amp; 1\\\\1 &amp; 4 &amp; 2\\end{bmatrix}$ Solution: $$C_{11} = + \\left|\\begin{array}{} -1 &amp; 1 \\\\ 4 &amp; -2\\end{array}\\right| = -2 , C_{12} = 3, C_{13} = 5,C_{21} = 14, C_{22} = -7,C_{23} = -7$$$$adj A =\\begin{bmatrix}-2 &amp; 14 &amp; 4\\\\3 &amp; -7 &amp; 1\\\\5 &amp; -7 &amp; 3\\end{bmatrix}接下来套公式即可$$ 在计算机中，For a larger $n \\times n$ matrix (real or complex), Cramer’s rule is hopelessly inefficient.Computing just one determinant takes about as much work as solving $Ax = b$ by row reduction. Determinants as Area or Volume If $A$ is a $2 \\times 2$ matrix, the area of the parallelogram（平行四边形） determined by the columns of $A$ is $|detA|$.If $A$ is a $3 \\times 3$ matrix, the volume of the parallelepiped（平行六面体） determined by the columns of $A$ is $|detA|$. $$\\left|{}det\\begin{bmatrix}a &amp; 0 \\\\ 0 &amp; d\\end{bmatrix}\\right|=\\left|ad\\right| = {area \\space of \\space rectangle}$$ For example: Calculate the area of the parallelogram determined by the points $(-2,-2),(0,3),(4,-1)and (6,4)$ Solution: 求平行四边形面积如下：$$1、平移(如下图),新点：(0,0), (2,5),(6,1),(8,6)$$$$2、建立矩阵列向量,A =\\begin{bmatrix}2 &amp; 5\\\\5 &amp; 1\\end{bmatrix},\\left|detA\\right| = \\left|-28\\right|，面积是28$$ Linear TransformationsLet $T:R^2\\rightarrow R^2$ be the linear transformation determined by a $2 \\times 2$ matrix $A$. If $S$ is a parallelogram(or other finite area) in $R^2$, then $$(area-of-T(S)) = \\left|detA\\right| \\cdot (area-of-S)$$ If $T$ is determined by a $3 \\times 3$ matrix $A$, and if $S$ is a parallelepiped(or other finite volume) in $R^3$, then $$(volume-of-T(S)) = \\left|detA\\right| \\cdot (volume-of-S)$$ for example: Let $a$ and $b$ be positive numbers. Find the area of the region $E$ bounded by the ellipse whose equation is $$\\frac{x_1^2}{a^2} + \\frac{x_2^2}{b^2} = 1$$We claim that $E$ is the image of the unit disk $D$ under the linear transformation $T$ determined by the matrix $A = \\begin{bmatrix}a &amp; 0\\\\ 0 &amp; b\\end{bmatrix}$, because if $\\vec{u} =\\begin{bmatrix}u_1\\\\u_2\\end{bmatrix}$ ,$\\vec{x} = \\begin{bmatrix}x_1\\\\x_2\\end{bmatrix}$,and $\\vec{x} = A\\vec{u}$, then $$u_1 = \\frac{x_1}{a}, u_2 = \\frac{x_2}{b}$$ it follows that $\\vec{u}$ is in the unit disk, with $u_1^2 + u_2^2 \\leqslant 1$, if and only if $\\vec{x}$ is in E, with $(x_1/a)^2 + (x_2/b)^2 \\leqslant 1$, so the area of ellipse is :$$\\begin{aligned}area \\space of \\space ellipse &amp;= area \\space of \\space T(D)\\\\&amp;= \\left|detA\\right| \\cdot area \\space of \\space D\\\\&amp;= ab \\cdot \\pi (1)^2 \\\\&amp;= \\pi ab\\end{aligned}$$","link":"/Math/Linear-Algebra/C3-Determinants/"},{"title":"something-from-vector-implementation","text":"This article is for the readers who have a basic background of math, graphics, c++. Although I have written the code about Vector2,Vector3 by c++, but as time goes by, all the principles were forgotten. So I decided to write something about the simple program to get much more strong memory.If you search the implementation of vector in github, you can find lots examples. Here’s an example vector.hpp, actually it’s too hard for me to read. Today’s vector.hpp is about the really basic syntax in c++ such as operator overloading, friends, inline etc. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#pragma once#include &lt;cmath&gt;#include &lt;iostream&gt;class Vector3f{public: Vector3f() : x(0) , y(0) , z(0) {} Vector3f(float xx) : x(xx) , y(xx) , z(xx) {} Vector3f(float xx, float yy, float zz) : x(xx) , y(yy) , z(zz) {} Vector3f operator*(const float&amp; r) const { return Vector3f(x * r, y * r, z * r); } Vector3f operator/(const float&amp; r) const { return Vector3f(x / r, y / r, z / r); } Vector3f operator*(const Vector3f&amp; v) const { return Vector3f(x * v.x, y * v.y, z * v.z); } Vector3f operator-(const Vector3f&amp; v) const { return Vector3f(x - v.x, y - v.y, z - v.z); } Vector3f operator+(const Vector3f&amp; v) const { return Vector3f(x + v.x, y + v.y, z + v.z); } Vector3f operator-() const { return Vector3f(-x, -y, -z); } Vector3f&amp; operator+=(const Vector3f&amp; v) { x += v.x, y += v.y, z += v.z; return *this; } friend Vector3f operator*(const float&amp; r, const Vector3f&amp; v) { return Vector3f(v.x * r, v.y * r, v.z * r); } friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Vector3f&amp; v) { return os &lt;&lt; v.x &lt;&lt; \", \" &lt;&lt; v.y &lt;&lt; \", \" &lt;&lt; v.z; } float x, y, z;};class Vector2f{public: Vector2f() : x(0) , y(0) {} Vector2f(float xx) : x(xx) , y(xx) {} Vector2f(float xx, float yy) : x(xx) , y(yy) {} Vector2f operator*(const float&amp; r) const { return Vector2f(x * r, y * r); } Vector2f operator+(const Vector2f&amp; v) const { return Vector2f(x + v.x, y + v.y); } float x, y;};inline Vector3f lerp(const Vector3f&amp; a, const Vector3f&amp; b, const float&amp; t){ return a * (1 - t) + b * t;}inline Vector3f normalize(const Vector3f&amp; v){ float mag2 = v.x * v.x + v.y * v.y + v.z * v.z; if (mag2 &gt; 0) { float invMag = 1 / sqrtf(mag2); return Vector3f(v.x * invMag, v.y * invMag, v.z * invMag); } return v;}inline float dotProduct(const Vector3f&amp; a, const Vector3f&amp; b){ return a.x * b.x + a.y * b.y + a.z * b.z;}inline Vector3f crossProduct(const Vector3f&amp; a, const Vector3f&amp; b){ return Vector3f(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);} Scan the program above, here’s some tips: Inline Functions Reference Variables Operator Overloading Friends Inline Functions Inline functions are a C++ enhancement designed to speed up programs. The primary distinction between normal functions and inline functions is not in how you code them but in how the C++ compiler incorporates them into a program.To understand the distinction between inline functions and normal functions,you need to peer more deeply into a program’s innards.Let’s do that now. How do normal function calls work?The final product of the compilation process is an executable program,which consists of a set of machine language instructions.When you start a program,the operating system loads these instructions into the computer’s memory so that each instruction has a particular memory address.The computer then goes through these instructions step-by-step.Sometimes,as when you have a loop or a branching statement,program execution skips over instructions,jumping backward or forward to a particular address. Normal function calls also involve having a program jump to another address (the function’s address) and then jump back when the function terminates.Let’s look at a typical implementation of that process in a little more detail.When a program reaches the function call instruction, the program stores the memory address of the instruction immediately following the function call,copies function arguments to the stack (a block of memory reserved for that purpose),jumps to the memory location that marks the beginning of the function,executes the function code (perhaps placing a return value in a register),and then jumps back to the instruction whose address it saved. Jumping back and forth and keeping track of where to jump means that there is an overhead in elapsed time to using functions. How do inline functions work?C++ inline functions provide an alternative.In an inline function,the compiled code is “in line” with the other code in the program.That is,the compiler replaces the function call with the corresponding function code.With inline code,the program doesn’t have to jump to another location to execute the code and then jump back. Inline functions thus run a little faster than regular functions,but they come with a memory penalty.If a program calls an inline function at ten separate locations,then the program winds up with ten copies of the function inserted into the code. When use inline?You should be selective about using inline functions.If the time needed to execute the function code is long compared to the time needed to handle the function call mechanism,then the time saved is a relatively small portion of the entire process.If the code execution time is short,then an inline call can save a large portion of the time used by the non-inline call.On the other hand,you are now saving a large portion of a relatively quick process,so the absolute time savings may not be that great unless the function is called frequently. Inline versus MacrosThe inline facility is an addition to C++. C uses the preprocessor #define statement to provide macros, which are crude implementations of inline code. For example, here’s a macro for squaring a number: 1#define SQUARE(X) X*X This works not by passing arguments but through text substitution, with the X acting as a symbolic label for the “argument”: 123a = SQUARE(5.0); is replaced by a = 5.0*5.0;b = SQUARE(4.5 + 7.5); is replaced by b = 4.5 + 7.5 * 4.5 + 7.5;d = SQUARE(c++); is replaced by d = c++*c++; Only the first example here works properly. You can improve matters with a liberal application of parentheses: 1#define SQUARE(X) ((X)*(X)) Still, the problem remains that macros don’t pass by value. Even with this new definition, SQUARE(c++) increments c twice, but the inline square() function evaluates c , passes that value to be squared, and then increments c once. The intent here is not to show you how to write C macros. Rather, it is to suggest that if you have been using C macros to perform function-like services, you should consider converting them to C++ inline functions. Reference VariablesThe main use for a reference variable is as a formal argument to a function.If you use a reference as an argument,the function works with the original data instead of with a copy.References provide a convenient alternative to pointers for processing large structures with a function,and they are essential for designing classes. Creating a reference variable‘&amp;’ in c++ has two functions: to indicate the address of a variable to declare references 12int rats;int &amp; rodents = rats; // makes rodents an alias for rats In this context, &amp; is not the address operator.Instead,it serves as part of the type identifier. Just as char * in a declaration means pointer-to-char , int &amp; means reference-to-int .The reference declaration allows you to use rats and rodents interchangeably;both refer to the same value and the same memory location. Difference between pointer and reference?123int rats = 101;int &amp; rodents = rats; // rodents a referenceint * prats = &amp;rats; // prats a pointer Then you could use the expressions rodents and *prats interchangeably with rats and use the expressions &amp;rodents and prats interchangeably with &amp;rats .From this standpoint,a reference looks a lot like a pointer in disguised notation in which the * dereferencing operator is understood implicitly.And,in fact,that’s more or less what a reference is.But there are differences besides those of notation.For one,it is necessary to initialize the reference when you declare it;you can’t declare the reference and then assign it a value later the way you can with a pointer: 123int rat;int &amp; rodent;rodent = rat; // No, you can't do this. You should initialize a reference variable when you declare it. A reference is rather like a const pointer;you have to initialize it when you create it, and when a reference pledges its allegiance to a particular variable,it sticks to its pledge. That is, int &amp; rodents = rats; (equals to) int * const pr = &amp; rats; References as Function Parameterscode from[1] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;using namespace std;void swapr(int &amp; a, int &amp; b); // a, b are aliases for intsvoid swapp(int * p, int * q); // p, q are addresses of intsvoid swapv(int a, int b); // a, b are new variablesint main(){ int wallet1 = 300; int wallet2 = 350; cout &lt;&lt; \"wallet1 = $\" &lt;&lt; wallet1; cout &lt;&lt; \" wallet2 = $\" &lt;&lt; wallet2 &lt;&lt; endl; cout &lt;&lt; \"Using references to swap contents:\\n\"; swapr(wallet1, wallet2); // pass variables cout &lt;&lt; \"wallet1 = $\" &lt;&lt; wallet1; cout &lt;&lt; \" wallet2 = $\" &lt;&lt; wallet2 &lt;&lt; endl; cout &lt;&lt; \"Using pointers to swap contents again:\\n\"; swapp(&amp;wallet1, &amp;wallet2); // pass addresses of variables cout &lt;&lt; \"wallet1 = $\" &lt;&lt; wallet1; cout &lt;&lt; \" wallet2 = $\" &lt;&lt; wallet2 &lt;&lt; endl; cout &lt;&lt; \"Trying to use passing by value:\\n\"; swapv(wallet1, wallet2); // pass values of variables cout &lt;&lt; \"wallet1 = $\" &lt;&lt; wallet1; cout &lt;&lt; \" wallet2 = $\" &lt;&lt; wallet2 &lt;&lt; endl; return 0;}void swapr(int &amp; a, int &amp; b) // use references{ int temp; temp = a; // use a, b for values of variables a = b; b = temp;}void swapp(int * p, int * q) // use pointers{ int temp; temp = *p; // use *p, *q for values of variables *p = *q; *q = temp;}void swapv(int a, int b) // try using values{ int temp; temp = a; // use a, b for values of variables a = b; b = temp;} The result is : 1234567wallet1 = $300 wallet2 = $350Using references to swap contents:wallet1 = $350 wallet2 = $300Using pointers to swap contents again:wallet1 = $300 wallet2 = $350Trying to use passing by value:wallet1 = $300 wallet2 = $350 The reference and pointer methods both successfully swap the contents of the two wallets,whereas the passing by value method fails. Operator OverloadingOperator overloading is a technique for giving object operations a prettier look. Operator overloading is an example of C++ polymorphism. 123456int main(){ Vector3f v (2,3,4); Vector3f w (1,2,1); std::cout &lt;&lt; v + w &lt;&lt; std::endl;} FriendsAs you’ve seen,C++ controls access to the private portions of a class object.Usually,public class methods serve as the only access,but sometimes this restriction is too rigid to fit particular programming problems.In such cases,C++ provides another form of access:the friend.Friends come in three varieties: Friend functions Friend classes Friend member functions Why we need friends?Often,overloading a binary operator (that is,an operator with two arguments) for a class generates a need for friends Multiplying a Time object by a real number provides just such a situation,so let’s study that case. 1A = B * 2.75; Remember,the left operand is the invoking object. Translates to the following member function call: 1A = B.operator*(2.75); But what about the following statement? 1A = 2.75 * B; // cannot correspond to a member function Conceptually, 2.75 * B should be the same as B * 2.75 ,but the first expression cannot correspond to a member function because 2.75 is not a type Time object.Remember, the left operand is the invoking object,but 2.75 is not an object.So the compiler cannot replace the expression with a member function call. One way around this difficulty is to tell everyone (and to remember yourself) that you can only write B * 2.75 but never write 2.75 * B .This is a server-friendly,client-beware solution,and that’s not what OOP is about. However,there is another possibility—using a nonmember function.(Remember,most operators can be overloaded using either member or nonmember functions.) A nonmember function is not invoked by an object;instead,any values it uses,including objects,are explicit arguments.Thus,the compiler could match the expression 1Time operator*(double m, const Time &amp; t); Using a nonmember function solves the problem of getting the operands in the desired order (first double and then Time ),but it raises a new problem:Nonmember functions can’t directly access private data in a class.Well,at least ordinary nonmember functions lack access.But there is a special category of nonmember functions,called friends,that can access private members of a class. Creating friendsThe first step toward creating a friend function is to place a prototype in the class declaration and prefix the declaration with the keyword friend . Like the code we showed in the beginning. 1234friend Vector3f operator*(const float&amp; r, const Vector3f&amp; v){ return Vector3f(v.x * r, v.y * r, v.z * r);} This prototype has two implications: Although the operator*() function is declared in the class declaration,it is not a member function.So it isn’t invoked by using the membership operator. Although the operator*() function is not a member function,it has the same access rights as a member function. Are friends unfaithful to OOP?At first glance, it might seem that friends violate the OOP principle of data hiding because the friend mechanism allows nonmember functions to access private data. However, that’s an overly narrow view. Instead, you should think of friend functions as part of an extended interface for a class. For example, from a conceptual point of view, multiplying a double by a Time value is pretty much the same as multiplying a Time value by a double . That the first requires a friend function whereas the second can be done with a member function is the result of C++ syntax, not of a deep conceptual difference. By using both a friend function and a class method, you can express either operation with the same user interface. Also keep in mind that only a class declaration can decide which functions are friends, so the class declaration still controls which functions access private data. In short, class methods and friends are simply two different mechanisms for expressing a class interface. A common kind of friend: Overloading the &lt;&lt; OperatorFrom the code in the begining,we see that : 1234friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Vector3f&amp; v){ return os &lt;&lt; v.x &lt;&lt; \", \" &lt;&lt; v.y &lt;&lt; \", \" &lt;&lt; v.z;} In its most basic incarnation,the &lt;&lt; operator is one of C and C++’s bit manipulation operators;it shifts bits left in a value.But the ostream class overloads the operator,converting it into an output tool.Recall that cout is an ostream object and that it is smart enough to recognize all the basic C++ types.That’s because the ostream class declaration includes an overloaded operator&lt;&lt;() definition for each of the basic types.That is,one definition uses an int argument,one uses a double argument,and so on.So one way to teach cout to recognize a Vector3f object is to add a new function operator definition to the ostream class declaration.But it’s a dangerous idea to alter the iostream file and mess around with a standard interface. Instead,use the Vector3f class declaration to teach the Vector3f class how to use cout. So this is the basic syntax, anyway, there’s still lots deeper knowledge there… if I have met much more advanced code, I will write this article again. References:[1]C++ Primer Plus.","link":"/C/something-from-vector-implementation/"},{"title":"Function-Template","text":"This is for the readers who have basic c++ background. If you want to get the rough sketch of funtion template of c++, then there it is. I suggest an online c++ compiler : http://coliru.stacked-crooked.com/ (You can test your simple programs on it.) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;array&gt;using namespace std;std::function&lt;int(int)&gt; Functional;int TestFunc(int a){ return a;}auto lambdaFn = [](float a)-&gt;float{ return a; };class Functor{ public: int operator()(int a){return a;}};class TestClass{ public: int ClassMember(int a) { return a; } static int StaticMember(int a) { return a; }};int main(){ Functional = TestFunc; int result = Functional(10); //10 cout &lt;&lt; \"TestFunc：\"&lt;&lt; result &lt;&lt; endl; Functional = lambdaFn; result = Functional(22.00); //22 cout &lt;&lt; \"Lambda：\"&lt;&lt; result &lt;&lt; endl; Functor testFunctor; Functional = testFunctor; result = Functional(30); //30 cout &lt;&lt; \"Functor：\"&lt;&lt; result &lt;&lt; endl; TestClass testObj; Functional = std::bind(&amp;TestClass::ClassMember, testObj, std::placeholders::_1); result = Functional(40); //40 cout &lt;&lt; \"TestClass：\"&lt;&lt; result &lt;&lt; endl; Functional = TestClass::StaticMember; result = Functional(50); //50 cout &lt;&lt; \"TestClass(static)：\"&lt;&lt; result &lt;&lt; endl; return 0;} function is a kind of wrapper,which provides a way to handle several funtion-like forms uniformly. If you know polymorphism, then this is easy to understand. Let’s see another code segment. 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;map&gt;using namespace std;int add(int x,int y){return x+y;}struct divide{ int operator()(int denominator,int divisor) { return denominator/divisor; }};int main(){ map&lt;char,function&lt;int(int,int)&gt;&gt; op = { {'+',add}, {'/',divide()}, {'-',[](int i,int j){return i-j;}} }; cout &lt;&lt; op['+'](1, 2) &lt;&lt; endl; //3 cout &lt;&lt; op['-'](1, 2) &lt;&lt; endl; //-1 cout &lt;&lt; op['/'](1, 2) &lt;&lt; endl; //0} Reference: https://www.cnblogs.com/reboost/p/11076511.html","link":"/C/function-template/"},{"title":"Learn-from-Anima2D","text":"This article is kind of an essay, not a very specific,technical one. Anima2D is a plugin for Unity to make skeleton-based animation,I have learned how to use it making my character Ideling on Bilibili, I pushed the result on github. However,I am a cs-er.So the source code of this plugin has a fatal attraction for me. I wonder why the author didn’t write any annotation for the project, this makes my reading really really tough. Maybe experienced-man never write annotations…the conclusion was based on my observation in my coding life up to now…Since I am a “chicken dish”,which means “菜鸡” in Chinese,I decided to write my own understanding step by step(kind of diary style) Life is so hard```(cry by chicken dish Anna) 2020.6.6I have been confused by Editor and EditorWindow and SciptObject and SerializedObject for a few days. Now here’s the tips: Editor for Inspector. EditorWindow for Windows, you can also add your custom menu to Window menu by using [MenuItem(“Window/xxx)] ScriptObject is for making the class as a .asset file.So AssetDatabase.xxx used frequently. SerializedObject to make the data serialized to show on the Inspector, also can make some relationships with Undo system. Project structure annotations","link":"/uncategorized/Learn-from-Anima2D/"},{"title":"const&constexpr","text":"While reviewing homework-code in GAMES101, I learned new things : not only the c++ grammer ,but also the graphics-algorithms, also how to architecture projects framwork. This is really amazing, I would like to express my gratitude to Prof.Yan and all the TAs. This blog is about constexpr, which is a new feature in c++11. First we learn const,then constexpr. References: [1]3D Math Primer for Graphics and Game Development 2nd Edition.[2]Fundamentals of Computer Graphics and 3rd Edition.[3]Unity+Shader入门精要[4]Unity3d Mannual[5]GAMES","link":"/C/const&constexpr/"}],"tags":[{"name":"Geometry","slug":"Geometry","link":"/tags/Geometry/"},{"name":"Linear Algebra","slug":"Linear-Algebra","link":"/tags/Linear-Algebra/"},{"name":"Rendering","slug":"Rendering","link":"/tags/Rendering/"},{"name":"DeepLearning","slug":"DeepLearning","link":"/tags/DeepLearning/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Animation","slug":"Animation","link":"/tags/Animation/"}],"categories":[{"name":"Math","slug":"Math","link":"/categories/Math/"},{"name":"Graphics","slug":"Graphics","link":"/categories/Graphics/"},{"name":"Linear Algebra","slug":"Math/Linear-Algebra","link":"/categories/Math/Linear-Algebra/"},{"name":"Geometry","slug":"Math/Geometry","link":"/categories/Math/Geometry/"},{"name":"DeepLearning","slug":"DeepLearning","link":"/categories/DeepLearning/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"Rendering","slug":"Graphics/Rendering","link":"/categories/Graphics/Rendering/"}]}